{"meta":{"title":"Blog-Q","subtitle":null,"description":null,"author":"戚浩强","url":"https://blog.qihaoqiang.cn","root":"/"},"pages":[],"posts":[{"title":"apache和nginx简单区分","slug":"apache和nginx简单区分","date":"2020-01-14T10:44:12.000Z","updated":"2020-01-15T06:27:44.918Z","comments":true,"path":"post/4c8dcffc.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/4c8dcffc.html","excerpt":"QHQ-【问题描述】web服务器该选择apache还是nginx","text":"QHQ-【问题描述】web服务器该选择apache还是nginx\\一、apache与nginx的区别：**​ 1、二者最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程 。nginx处理静态文件好,耗费内存少.但无疑apache仍然是目前的主流,有很多丰富的特性.所以还需要搭配着来.当然如果能确定nginx就适合需求,那么使用nginx会是更经济的方式。​ 2、nginx的负载能力比apache高很多。最新的服务器也改用nginx了。而且nginx改完配置能-t测试一下配置有没 有问题。​ 3、apache重启的时候发现配置出错了，会很崩溃，改的时候都会非常小心翼翼现在看有好多集群站，前端nginx抗并发，后端apache集群， 配合的也不错。​ 4、nginx处理动态请求是鸡肋，一般动态请求要apache去做，nginx只适合静态和反向。​ 5、从经验来看，nginx是很不错的前端服务器，负载性能很好，nginx，用webbench模拟10000个静态文件请求毫不吃力。 apache对php等语言的支持很好，此外apache有强大的支持网络，发展时间相对nginx更久，bug少但是apache有先天不支持多核心处理负载鸡肋的缺点，建议使用nginx做前端，后端用apache。大型网站建议用nginx自代的集群功能。​ 6、大部分情况下nginx都优于APACHE，比如说静态文件处理、PHP-CGI的支持、反向代理功能、前端 Cache、维持连接等等。在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出现Apache进程数 飙升，从而拒绝服务的现象。​ 7、Apache在处理动态有优势，Nginx并发性比较好，CPU内存占用低，如果rewrite频繁，那还是Apache吧！​ 8、一般来说，需要性能的web 服务，用nginx 。如果不需要性能只求稳定，那就apache 吧。二、apache与nginx优缺点比较1、nginx相对于apache的优点：轻量级，同样web 服务，比apache 占用更少的内存及资源 ；抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 ；高度模块化的设计，编写模块相对简单 ；社区活跃，各种高性能模块出品迅速啊 ；Nginx本身就是一个反向代理服务器 ，Nginx支持7层负载均衡；Nginx可能会比apache支持更高的并发，nginx配置文件写的很简洁，正则配置让很多事情变得简单运行效率高，占用资源少，代理功能强大，很适合做前端响应服务器 ！2、apache 相对于nginx 的优点：rewrite ，比nginx 的rewrite 强大 ；模块超多，基本想到的都可以找到 ；少bug ，nginx 的bug 相对较多 ；超稳定 ，Aapche依然是大部分公司的首先，因为其成熟的技术和开发社区已经 也是非常不错的性能。\\三、为什么现在 Nginx 才是 Web 服务器的首选**作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。在高连接并发的情况下，Nginx是Apache服务器不错的替代品: Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一. 能够支持高达 50,000 个并发连接数的响应, 感谢Nginx为我们选择了 epoll and kqueue 作为开发模型.Nginx作为负载均衡服务器: Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务, 也可以支持作为 HTTP代理 服务器对外进行服务. Nginx采用C进行编写, 不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多.​ 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器）, Last.fm 描述了成功并且美妙的使用经验.​ Nginx 是一个安装非常的简单 , 配置文件非常简洁（还能够支持perl语法）, Bugs 非常少的服务器: Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够不间断服务的情况下进行软件版本的升级 .​ Nginx 配置简洁, Apache 复杂 ， Nginx 静态处理性能比 Apache 高 3倍以上 ， Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端用， Apache 的组件比 Nginx 多 。 现在 Nginx 才是 Web 服务器的首选 。链接","categories":[],"tags":[]},{"title":"md短代码怎么写","slug":"md短代码怎么写","date":"2019-12-19T09:15:15.000Z","updated":"2019-12-19T09:39:58.097Z","comments":true,"path":"post/2ffe5c2d.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/2ffe5c2d.html","excerpt":"QHQ-【问题描述】刚写了一篇博客，然后发现一个小bug，写的&lt;input&gt;&lt;/input&gt;字段发表出来是个文本输入框，然后看了看 Markdown 基本语句发现。。。。","text":"QHQ-【问题描述】刚写了一篇博客，然后发现一个小bug，写的&lt;input&gt;&lt;/input&gt;字段发表出来是个文本输入框，然后看了看 Markdown 基本语句发现。。。。如果正常直接在文章中写&lt;input&gt;&lt;/input&gt;，你得到的将会是这样：所以你需要看一下语法了，发现 &lt; 不是直接输入的，而是需要输入 &amp;lt；，来代替 &lt; ，&gt; 则是 *&amp;gt； *。所以你可以写&amp;lt；input&gt;&lt;/input*&amp;gt； *,这样就是&lt;input&gt;&lt;/input&gt; 。","categories":[],"tags":[]},{"title":"Java web 的form表单问题","slug":"JAVA Web的form表单问题","date":"2019-12-19T08:29:36.000Z","updated":"2019-12-19T09:04:18.866Z","comments":true,"path":"post/undefined.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/undefined.html","excerpt":"QHQ-【问题描述】今天做Java web项目的时候，里面一个功能让我form表单里面套表单了，但是里面的form 提交action中参数无效。直接action外层form，所以就记录下form表单的一些问题。","text":"QHQ-【问题描述】今天做Java web项目的时候，里面一个功能让我form表单里面套表单了，但是里面的form 提交action中参数无效。直接action外层form，所以就记录下form表单的一些问题。Form表单提交数据（Java web）java web 两个表单form怎么设置两个提交？也可以是一表单form，多提交。Acton只能有一个submit提交，在设置一个submit还是action外层form。所以怎么来用两个submit来指向不同的响应呢？一、使用formmethod和formaction属性在使用里面使用type=”submit” formmethod=”get” formaction=””即可。具体如下：123456789101112131415161718192021&lt;form action=\"query.do\" method=\"post\" align=\"center\"&gt; &lt;table border=\"1\" align=\"center\" text-align:center\"&gt; &lt;tr&gt; &lt;td&gt;&lt;%=book.getBookName()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getPrice()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getAuthor()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBr()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getCounts()%&gt;&lt;/td&gt; &lt;td&gt; &lt;form action=\"edit.do?Id=&lt;%=book.getId()%&gt;\" method=\"get\"&gt; &lt;input type=\"text\" id=\"counts\" name=\"counts\"width:50px\" &gt; &lt;input type=\"hidden\" id=\"Id\" name=\"Id\" value=\"&lt;%=book.getId()%&gt;\" style=\"width: 0px\"&gt; &lt;input type=\"submit\" formmethod=\"get\" formaction=\"edit.do?Id=&lt;%=book.getId()%&gt;\" value=\"修改\"&gt;//调用edit方法，方式为get，（也可以修改为post，看自己需要） &lt;/form&gt; &lt;tr&gt; &lt;td colspan=\"7\"&gt;&lt;input type=\"submit\" value=\"查询\" /&gt;&lt;/td&gt;//调用qurry方法，方式为GET &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;二、设置不同函数，使用onclick属性1、表单中设置两个提交按钮：加密、解密；点击后分别调用不同的方法1234&lt;s:form id=\"Form\" action=\"\" namespace=\"/\"&gt; &lt;button onclick=\"encrypt()\"&gt;加密&lt;button&gt; &lt;button onclick=\"decrypt()\"&gt;解密&lt;/button&gt;&lt;s:form&gt;2、在不同的函数中设置要提交的地址123456789101112131415&lt;script&gt;//点击加密按钮调用此方法function encrypt()&#123; //跳转到encrypt.aciton document.getElementById(\"Form\") .action=\"$&#123;pageContext.request.contextPath&#125;/enAndDeAction_encrypt.action?\"; document.getElementById(\"Form\").submit; &#125; //点击加密按钮调用此方法function decrypt()&#123;document.getElementById(\"Form\").action=\"$&#123;pageContext.request.contextPath&#125;/enAndDeAction_decrypt.action?\";document.getElementById(\"Form\").submit; &#125;&lt;/script&gt;三、Form的Action路径问题页面通过表单（form）想服务器提交数据的时候有两种形式，一个是POST,另一个是GET。两种的一个区别是GET会直接把数据附加在url的后面，而POST发送的数据放置在http包中。form的action属性就是提交数据的url地址，method属性可以指定是GET或POST。需要注意的是如果采用GET方式，那么action url中参数都会被丢弃，提交时候只会把form中的数据拼接在url向服务器提交；但是POST的方式则不会这样，它会按照action指定的url进行提交数据，包含url后面跟着的参数和参数值我遇到的是Form表单提交到servelet处理时遇到的问题：123（1）&lt;form action=\"①？\" method=\"②？\"&gt; //表单的内容 &lt;/form&gt;（2）对应的处理用户请求的servlet类为Servlet.java，其中查询方法如下：123456789101112private void query(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO 自动生成的方法存根 req.setCharacterEncoding(\"UTF-8\");// 解决POST方法的中文乱码问题 t = req.getParameter(\"counts\"); // 1.调用CustomerDAO的getAll()方法 List&lt;User&gt; books = bd.findAll(); System.out.println(books); // 2.将Customer的集合放入request中 req.setAttribute(\"books\", books); // 3.转发页面到index.jsp(不能使用重定向) req.getRequestDispatcher(\"/book.jsp\").forward(req, resp); &#125;（3）配置web.xml文件：123456789&lt;servlet&gt; &lt;display-name&gt;③Servlet&lt;/display-name&gt; &lt;servlet-name&gt;Servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qhq.servlet.Servlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;③Servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;①*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;然后在query.jsp中应该是：1&lt;form action=\"①query.do\" method=\"②Post\"&gt;这样的话query.jsp的url是http://localhost:8080/jsp/query.do而Servlet.java的url是http://localhost:8080/jsp/Servlet注:web.xml中③对应的两个servlet-name要一致；①中的url-pattern要与form表单中的action属性值一致。参考连接如下：参考1参考2","categories":[],"tags":[]},{"title":"Win10无限刷新","slug":"Win10无限刷新","date":"2019-12-16T11:58:15.000Z","updated":"2019-12-19T09:39:58.096Z","comments":true,"path":"post/685c7446.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/685c7446.html","excerpt":"QHQ-【问题描述】​ 怎么样修复Win10系统 ，win10在选择默认应用就是更改不了，重置也没有反应，打开一个包含html文件的文件夹，桌面就无限刷新","text":"QHQ-【问题描述】​ 怎么样修复Win10系统 ，win10在选择默认应用就是更改不了，重置也没有反应，打开一个包含html文件的文件夹，桌面就无限刷新win10无限刷新我在使用电脑的时候，忽然发现我打开一个文件夹，桌面在无限刷新，于是就检查一下，发现是包含.html的文件夹都会造成这个无限刷新的bug。于是寻找解决办法。有以下两种：方法一：利用文件检查工具修复右击开始图标（电脑左下角的小图标），出现下面界面，点击管理员的Windows powerShell：然后输入sfc /scannow ，回车运行。方法二：即设置注册页来设置回到原始设置。先Win+R 打开运行界面，输入regedit，确定运行。接着按着箭头所指一步步走。都是左击，然后确定。选择完全控制，然后点击确定。之后就是确定，确定。。。（可能会反应一下，看自己电脑反应速度，我的是反应了两秒就好了），然后重启，即可。补充：如果第二点还没有反应，可以从控制面板→程序→默认程序→设置默认程序，自己再调整一下默认应用，也可以根据文件后缀名调整默认打开程序。","categories":[],"tags":[{"name":"Win10","slug":"Win10","permalink":"https://blog.qihaoqiang.cn/tags/Win10/"},{"name":"默认应用","slug":"默认应用","permalink":"https://blog.qihaoqiang.cn/tags/%E9%BB%98%E8%AE%A4%E5%BA%94%E7%94%A8/"},{"name":"html","slug":"html","permalink":"https://blog.qihaoqiang.cn/tags/html/"},{"name":"注册表","slug":"注册表","permalink":"https://blog.qihaoqiang.cn/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"},{"name":"无限刷新","slug":"无限刷新","permalink":"https://blog.qihaoqiang.cn/tags/%E6%97%A0%E9%99%90%E5%88%B7%E6%96%B0/"}]},{"title":"在人间凑数的日子(三）","slug":"在人间凑数的日子(三）","date":"2019-12-06T06:53:21.000Z","updated":"2019-12-06T13:01:17.061Z","comments":true,"path":"post/7562c651。.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/7562c651%E3%80%82.html","excerpt":"","text":"在人间凑数的日子（三）终于长到能与父亲碰杯的年纪，却没能成为他的骄傲。后来才发现，那并不是属于我的花，我只是途经她的绽放。曾以为贫穷是指饥饿，衣不附体，现在才懂得，它是孤独与无人问津。散伙是人间常态，我们又不是什么例外。一直想做一个特别的人，现在我做到了，我特别的无助，特别的难过。有时候也挺佩服自己，能咽下一肚子的话和心酸。条条大路通罗马，可有的人就出生在罗马。曾经有一个女孩儿追我，被我拒绝了，我没车没房，她不懂事，可我不能。所谓眉间的故事，不是喜欢就是辜负。后来我发现这世界真的很大，没有刻意见面，这辈子就再也见不到了。成熟，就是看以前的自己像个笨蛋。自你走后，好像不开心了好多年，原来不开心也可以成为习惯。回了趟故乡，故乡的气候一直没变，只是我却像个旅人。请不要用你那微不足道的成绩，来对我指指点点，因为我不配。","categories":[{"name":"在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/categories/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}],"tags":[{"name":"-在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/tags/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}]},{"title":"在人间凑数的日子（二）","slug":"在人间凑数的日子（二）","date":"2019-12-06T06:23:21.000Z","updated":"2019-12-06T08:00:46.044Z","comments":true,"path":"post/46848691.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/46848691.html","excerpt":"","text":"在人间凑数的日子（二）​ 年轻不懂爱情与友情，​ 长大后才懂得爱情是那么不容易，​ 友情是那么的脆弱。生活从来都是这样，不把我放在眼里。​ 你羡慕的生活背后，​ 都是你熬不起的苦。​ 自己都是满身灰暗，​ 还总想给别人一些光。​ 不要假装努力，​ 因为结果不会陪你演戏，​ 行为在于自己，未来依旧可期。​ 微笑并不代表快乐，​ 那只是一种表情。​ 你试图以离开引起别人的注意，​ 却不知道你是真的离开了，​ 并没有任何人记住你。​ 小时候总觉得要做什么样的人，​ 绝不能像某些人一样，​ 长大后，却成了当初最讨厌的人。​ 大事办不了，​ 小事不爱办。​ 很多道理我都懂，​ 结果无能想到也只能接受，​ 但是，我就是难受。​ 好看的皮囊你玩不起，​ 有趣的灵魂看不上你。​ 遗憾的是，​ 到最后我们连一张合照都没有。​ 我讨厌无边的猜忌和怀疑，​ 觉得人和人之间要多一点信任，​ 直到有一天，我把它们当成了兴趣。​ 她向你倾诉着寂寞，​ 你确认为那是爱情。​ 原来，所有失去的，会以另一种方式归来。​ 原来，虞美人终将盛开在这满山坡上。​ 原来，也终会有人陪我爱天爱地的四处风流。","categories":[{"name":"在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/categories/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}],"tags":[{"name":"-在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/tags/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}]},{"title":"在人间凑数的日子（一）","slug":"在人间凑数的日子（一）","date":"2019-12-06T05:53:21.000Z","updated":"2019-12-06T12:56:33.931Z","comments":true,"path":"post/76926a49.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/76926a49.html","excerpt":"","text":"在人间凑数的日子（一）鱼和熊掌不可兼得，唯独穷和单身可以。爷爷没有输给战火，父亲没有输给贫穷，我却输给了和平年代的生活和爱情，以及太过自由。我不记得小时候的梦想了，但绝对不是买一套房子。感觉什么都不缺，却又好像什么都没有。以为为是的深情，一厢情愿的热情。老说找不到理想中的另一半，问问自己，成为理想中的自己了吗？世界很美好，能让两个毫无关系的人走到一起，世界也很残酷，硬生生让两个相爱的人再没有未来。活着，就是一个接着一个的妥协。嫉妒使我面目全非，暗恋让我卑微入骨。自幼以为会有一番作为，衣锦还乡，现在想想，只希望父母在家过的好。有些事只适合烂在心里，无声无息的忘记。我到底经历了什么？才能收起暴躁的脾气和骄傲。","categories":[{"name":"在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/categories/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}],"tags":[{"name":"在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/tags/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}]},{"title":"关于Hexo主题的一些踩过的坑","slug":"关于Hexo主题的一些踩过的坑","date":"2019-11-24T05:48:07.341Z","updated":"2019-12-08T08:05:54.855Z","comments":true,"path":"post/7cf57d5c.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/7cf57d5c.html","excerpt":"","text":"Hexo主题的一些踩过的坑一、主题选择问题首先你需要在官网hexo选择你喜欢的主题。主要下载步骤有：Hxeo+Github pages。二、绑定域名问题每一次推送都会把你在setting设置的域名给覆盖，让你每一次都需要重新绑定一些域名，很麻烦。所以我就上网搜索与尝试，找到解决方法，首先在你hexo根目录找到source*目录，先新建.txt文件，在里面写入你要绑定的域名。再重命名为CNAME*，删除后缀名。使其没有后缀名，类型为文件。然后在github的setting里设置一次（保险设置一次，不设置也行）。三、主题内容更改在这只说一些我自己碰到的，基本上一般的坑网上都有详细教程。3.1、标题，作者和文字的更换​ 基本上在hexo*的根目录下的_config.yml*文件就可以更改了。注意：冒号后面需要空一格，不然会报错。默认语言为en，中文为zh—CN（有需要可以更改，一般不变）。3.2、js特效的更换添加​ 比如我的添加点击显示文字的特效：​ 以我选择miho主题为例，先添加点击显示文字的js（目录为..\\themes\\miho\\source\\js\\click_show_text.js）click_show_text.js：12345678910111213141516171819202122232425262728293031323334var a_idx = 0;jQuery(document).ready(function($) &#123; $(&quot;body&quot;).click(function(e) &#123; var a = new Array (&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);//文字自己填写所想要的 var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; &quot;z-index&quot;: 5, &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;#FF0000&quot; &#125;); $(&quot;body&quot;).append($i); $i.animate(&#123; &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 &#125;, 3000, function() &#123; $i.remove(); &#125;); &#125;); setTimeout(&apos;delay()&apos;, 2000);&#125;);function delay() &#123; $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;);&#125;​ 然后需要在..\\themes\\miho\\layout\\layout.ejs添加语句： ` &lt;!--单击显示文字--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/click_show_text.js&quot;&gt;&lt;/script&gt; `​ 网上可以搜索自己喜欢的类型，步骤一样。未完待续","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.qihaoqiang.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.qihaoqiang.cn/tags/hexo/"}]},{"title":"bat批修改文件后缀名","slug":"bat简单批文件操作","date":"2019-11-10T16:00:00.000Z","updated":"2019-12-06T07:53:42.832Z","comments":true,"path":"post/642b6e07.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/642b6e07.html","excerpt":"","text":"今天先说说bat最简单的操作1ren *.jpg *.txt此语句可以把当前文件夹的所有jpg照片转换为txt格式，（有利于隐藏照片哦）。接下来就简单来说一下怎么具体操作吧新建txt文本在里面填写上面语句修改txt后缀名为bat提示：.jpg 意思是任意文件名的jpg格式，当然也可以.* ，表示任意文件文件格式，第二个*.txt意思是任意任意文件名的最终格式。就是原文件名不变，只修改后缀名。（后缀名可以根据自己的要求自己更改）。未完待续。。。","categories":[{"name":"bat","slug":"bat","permalink":"https://blog.qihaoqiang.cn/categories/bat/"}],"tags":[{"name":"bat","slug":"bat","permalink":"https://blog.qihaoqiang.cn/tags/bat/"},{"name":"文件后缀名修改","slug":"文件后缀名修改","permalink":"https://blog.qihaoqiang.cn/tags/%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%E4%BF%AE%E6%94%B9/"},{"name":"显示文件后缀名","slug":"显示文件后缀名","permalink":"https://blog.qihaoqiang.cn/tags/%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/"}]},{"title":"C++半数集问题","slug":"半数集","date":"2019-10-25T04:38:19.040Z","updated":"2019-12-06T07:50:48.214Z","comments":true,"path":"post/c5f70282.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/c5f70282.html","excerpt":"QHQ-【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：（1）n∈set(n);（2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；（3）按此规则进行处理，直到不能再添加自然数为止。","text":"QHQ-【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：（1）n∈set(n);（2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；（3）按此规则进行处理，直到不能再添加自然数为止。12345678910111213141516171819【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：（1）n∈set(n);（2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；（3）按此规则进行处理，直到不能再添加自然数为止。例如，set(6)=&#123;6,16,26,126,36,136&#125;。半数集set（6）中有6个元素。注意，该半数集是多重集。【算法设计】对于给定的自然数n，计算半数集set(n)中的元素个数。【输入形式】只有1行，给出整数n（0&lt;n&lt;1000）。【输出形式】只有1行，给出半数集set(n)中的元素个数。【样例输入】6【样例输出】61234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int my_set(int n)&#123; int set_count = 1; if (n == 1) return 1; else &#123; int i = 1; while (i &lt;= (n / 2)) &#123; set_count = set_count + my_set(i); i++; &#125; return set_count; &#125;&#125;int main()&#123; int n = 0; cin &gt;&gt; n; cout &lt;&lt; my_set(n);&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://blog.qihaoqiang.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"半数集问题","slug":"半数集问题","permalink":"https://blog.qihaoqiang.cn/tags/%E5%8D%8A%E6%95%B0%E9%9B%86%E9%97%AE%E9%A2%98/"}]},{"title":"C++众数问题","slug":"众数问题","date":"2019-10-21T14:17:31.943Z","updated":"2019-12-06T07:53:06.645Z","comments":true,"path":"post/d2fd1ed9.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/d2fd1ed9.html","excerpt":"QHQ-【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。","text":"QHQ-【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。12345678910111213141516171819202122232425262728【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S=&#123;1,2,2,2,3,5&#125;。多重数S的众数是2，其重数为3 。【算法设计】对于给定的由n个自然数组成的多重集S，计算S的众数及其重数。【输入形式】第1行为多重数集S中元素个数n；接下来的n行中，每行有一个自然数。【输出形式】输出文件有2行，第1行是众数，第2行是重数。【样例输入】6122235【样例输出】231234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAXINT 10000int main()&#123; int n = 0; cin &gt;&gt; n; int a[MAXINT] = &#123; 0 &#125;; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + n); int maxcount = 0; int maxcount_index = 0; int temp = 1; int b[MAXINT] = &#123; 0 &#125;; b[0] = a[0]; int b_index = 1; bool flag = false; for (int i = 0; i &lt; (n - 1); i++) &#123; if (a[i] != a[i + 1]) &#123; b[b_index++] = a[i + 1]; flag = true; &#125; else temp++; if (maxcount &lt; temp) &#123; maxcount = temp; maxcount_index = (b_index - 1); &#125; if (flag) &#123; temp = 1; flag = false; &#125; &#125; cout &lt;&lt; b[maxcount_index] &lt;&lt; endl; cout &lt;&lt; maxcount;&#125;Sort() 数组排列函数。用法1、sort函数可以三个参数也可以两个参数，必须的头文件#include &lt; algorithm&gt;和using namespace std;2、它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)3、Sort函数有三个参数：（第三个参数可不写）（1）第一个是要排序的数组的起始地址。（2）第二个是结束的地址（最后一位要排序的地址）（3）第三个参数是排序的方法，可以是从大到小也可是从小到&gt;大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。两个参数用法1234567891011121314 #include &lt;iostream&gt; #include &lt;algorithm&gt; int main() &#123; int a[20]=&#123;2,4,1,23,5,76,0,43,24,65&#125;,i; for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+20); for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0; &#125; ``` &gt;输出结果是升序排列。（两个参数的sort默认升序排序）12---##三个参数 // sort algorithm example#include#include#includeusing namespace std;bool myfunction (int i,int j) { return (i&lt;j); }//升序排列bool myfunction2 (int i,int j) { return (i&gt;j); }//降序排列struct myclass {bool operator() (int i,int j) { return (i&lt;j);}} myobject;int main () {int myints[8] = {32,71,12,45,26,80,53,33};vectormyvector (myints, myints+8); // 32 71 12 45 26 80 53 33// using default comparison (operator &lt;):sort (myvector.begin(), myvector.begin()+4); //(12 32 45 71)26 80 53 33// using function as compsort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)//std::sort (myints,myints+8,myfunction);不用vector的用法// using object as compsort (myvector.begin(), myvector.end(), myobject); //(12 26 32 33 45 53 71 80)// print out content:cout &lt;&lt; “myvector contains:”;for (std::vector::iterator it=myvector.begin(); it!=myvector.end(); ++it)//输出cout &lt;&lt; ‘ ‘ &lt;&lt; *it;cout &lt;&lt; ‘\\n’;return 0;}12---## string 使用反向迭代器来完成逆序排列#includeusing namespace std;int main(){string str(“cvicses”);string s(str.rbegin(),str.rend());cout &lt;&lt; s &lt;&lt;endl;return 0;}//输出：sescivc```","categories":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"众数问题","slug":"众数问题","permalink":"https://blog.qihaoqiang.cn/tags/%E4%BC%97%E6%95%B0%E9%97%AE%E9%A2%98/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://blog.qihaoqiang.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++金币阵列","slug":"金币阵列","date":"2019-10-21T12:26:55.162Z","updated":"2019-12-06T07:51:12.912Z","comments":true,"path":"post/ec6b291e.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/ec6b291e.html","excerpt":"QHQ-【问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上，1表示金币背面朝上。金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。","text":"QHQ-【问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上，1表示金币背面朝上。金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。1234567891011121314151617181920212223242526问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上， 1表示金币背面朝上。金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。【输入形式】第1行有2个正整数m和n，用#隔开。以下m行是金币阵列的初始状态，每行有n个数字表示该行金币的状态，0表示正面朝上，1表示背面朝上。接着的m行是金币阵列的目标状态，不用#隔开 。【输出形式】输出计算出的最小变化次数。相应数据无解是，输出-1 。【样例输入】4#3101000110101101111011101【样例输出】2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;const int size1 = 100;int k, n, m, ccount, best;int b0[size1 + 1][size1 + 1], b1[size1 + 1][size1 + 1], b[size1 + 1][size1 + 1];bool found;void stringToInt(string str,int&amp; n,int&amp; m)&#123; int len = str.length(); int temp = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] != &apos;#&apos;) &#123; temp = temp * 10 + (int)str[i] - 48; &#125; else &#123; n = temp; temp = 0; &#125; &#125; m = temp;&#125;void trans1(int x) // 行翻转&#123; for (int i = 1; i &lt;= m; i++) b1[x][i] = b1[x][i] ^ 1; ccount++;&#125;void trans2(int x, int y) // 列交换&#123; for (int i = 1; i &lt;= n; i++) swap(b1[i][x], b1[i][y]); if (x != y) ccount++;&#125;bool same(int x, int y)&#123; for (int i = 1; i &lt;= n; i++) if (b0[i][x] != b1[i][y]) return false; return true;&#125;void acpy(int a[size1 + 1][size1 + 1], int b[size1 + 1][size1 + 1])&#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[i][j] = b[i][j];&#125;void answer()&#123; int x, y, j, p; //cin &gt;&gt; n &gt;&gt; m; string str; int temp = 0; cin &gt;&gt; str; stringToInt(str, n, m); // 原状态 b0 for (x = 1; x &lt;= n; x++) &#123; cin &gt;&gt; temp; for (y = 1; y &lt;= m; y++) &#123; b0[x][y] = temp % 10; temp /= 10; //cin &gt;&gt; b0[x][y]; &#125; &#125; // 目标状态 b1 for (x = 1; x &lt;= n; x++) &#123; cin &gt;&gt; temp; for (int y = 1; y &lt;= m; y++) &#123; b1[x][y] = temp % 10; temp /= 10; //cin &gt;&gt; b1[x][y]; &#125; &#125; acpy(b, b1); best = m + n + 1; for (j = 1; j &lt;= m; j++) &#123; acpy(b1, b); ccount = 0; trans2(1, j); // 列变换 int p; for (p = 1; p &lt;= n; p++) if (b0[p][1] != b1[p][1]) trans1(p); // 行变换 for (p = 1; p &lt;= m; p++) //找列相等的（ b1 的 q 列和 b0 的 p 列相等） &#123; found = false; for (int q = p; q &lt;= m; q++) if (same(p, q)) &#123; trans2(p, q); found = true; break; &#125; if (!found) break; &#125; if (found &amp;&amp; ccount &lt; best) best = ccount; &#125; if (best &lt; m + n + 1) &#123; cout &lt;&lt; best &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; //&#125;&#125;int main()&#123; answer(); return 0;&#125;StringToint() 函数获取输入的特殊格式，并分发数据给行n，列m。trans1() 和 trans2() 为行转换与列转换。","categories":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://blog.qihaoqiang.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"金币阵列","slug":"金币阵列","permalink":"https://blog.qihaoqiang.cn/tags/%E9%87%91%E5%B8%81%E9%98%B5%E5%88%97/"}]},{"title":"C++最大间隙","slug":"最大间隙","date":"2019-10-21T11:49:44.984Z","updated":"2019-12-06T07:53:18.716Z","comments":true,"path":"post/f08763f0.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/f08763f0.html","excerpt":"QHQ-【问题描述】给定n个实数x1,x2,…,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。","text":"QHQ-【问题描述】给定n个实数x1,x2,…,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。12345678910111213【问题描述】给定n个实数x1,x2,...,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。算法设计：对于给定的n个实数x1,x2,...,xn，计算它们的最大间隙。（只有一位小数）【输入形式】第一行有1个正整数n（n不超过10），接下来的1行有n个实数x1,x2,...,xn，中间用空格隔开。【输出形式】输出找到的最大间隙【样例输入】52.3 3.1 7.5 1.5 6.3【样例输出】3.2（保留一位小数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;const int MAX = 200001;double num[MAX];bool run()&#123; int n; if (scanf_s(&quot;%d&quot;, &amp;n) == EOF) return false; int i; double max = 0.0, min = INT_MAX; for (i = 0; i &lt; n; i++) &#123; scanf_s(&quot;%lf&quot;, &amp;num[i]); if (num[i] &gt; max) max = num[i]; if (num[i] &lt; min) min = num[i]; &#125; int* cnt = new int[n]; double* low = new double[n]; double* high = new double[n]; for (i = 0; i &lt; n; i++) &#123; cnt[i] = 0; low[i] = max; high[i] = min; &#125; double ave = (max - min) / (n - 1); for (i = 0; i &lt; n; i++) &#123; int tmp = (int)((num[i] - min) / ave); cnt[tmp]++; if (num[i] &gt; high[tmp]) high[tmp] = num[i]; if (num[i] &lt; low[tmp]) low[tmp] = num[i]; &#125; double t = high[0], res = 0.0; for (i = 1; i &lt; n; i++) &#123; if (cnt[i] &gt; 0) &#123; double tmp = low[i] - t; if (tmp &gt; res) res = tmp; t = high[i]; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; res &lt;&lt; endl; return true;&#125;int main()&#123; while (run()); return 0;&#125;因为我用的是vs2019，所以在scanf输出的时候会出现 C6031:返回值被忽略的问题：“scanf”，所以需要改写scanf为scanf_s。题目要求结果有一位小数，在C++中，是没有格式符的，所以想起用setprecision() 函数，但是使用这个函数，需要在头文件引入 #include，使用方式在此再简单回顾一下：1cout &lt;&lt; setprecision(2) &lt;&lt; res &lt;&lt;endl;这是保留小数点后两位（但是如果结果是整数则是整数，不自动 补零）1cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; res &lt;&lt; endl;在前面加上 fixed 就可以自动补零。3.再次附一个小吕哥的源码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define MAXINT 100000using namespace std;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; endl; double a[MAXINT] = &#123;0.0 &#125;; for(int i = 0;i &lt; n;i++)&#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n); double maxsub = 0.0; double temp = 0.0; for(int i = 0;i &lt; (n - 1);i++)&#123; temp = fabs(a[i] - a[i + 1]); if(maxsub &lt; temp)&#123; maxsub = temp; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; maxsub;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://blog.qihaoqiang.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"最大间隙","slug":"最大间隙","permalink":"https://blog.qihaoqiang.cn/tags/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%99/"},{"name":"C++格式化输出","slug":"C-格式化输出","permalink":"https://blog.qihaoqiang.cn/tags/C-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"}]},{"title":"2019Vs建立C++项目","slug":"2019Vs建立C++项目","date":"2019-10-19T09:44:51.024Z","updated":"2019-12-06T08:01:53.846Z","comments":true,"path":"post/597baf2d.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/597baf2d.html","excerpt":"","text":"","categories":[{"name":"-C++ -vs","slug":"C-vs","permalink":"https://blog.qihaoqiang.cn/categories/C-vs/"}],"tags":[]},{"title":"C++分割输入字符串","slug":"C++格式化输入","date":"2019-10-17T15:13:42.687Z","updated":"2019-12-06T07:53:52.972Z","comments":true,"path":"post/dab5e751.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/dab5e751.html","excerpt":"QHQ-It was day full of memories","text":"QHQ-It was day full of memoriesC++字符串分割C++没有split分割的函数！！！！C++没有c语言的那样方便的格式化输入，像c语言你如果想一次性输入1#2，而分别把1和2赋值给x和y，你可以这样：1scanf(&quot;%d#%d&quot;,&amp;x,&amp;y);当然你也可以自己定义一个方法来实现这个想法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstddef&gt;#include &lt;vector&gt;using namespace std;namespace strg&#123; //函数模板 template&lt;typename Container&gt; inline std::size_t strtok(std::string&amp; str, Container&amp; cont, const std::string defstr = &quot; &quot;) &#123; cont.clear(); std::size_t size = 0; std::size_t begpos = 0 ; std::size_t endpos = 0 ; begpos = str.find_first_not_of(defstr); while (begpos != std::string::npos) &#123; size++; endpos = str.find_first_of(defstr, begpos); if (endpos == std::string::npos) &#123; endpos = str.size(); &#125; string ssubstr = str.substr(begpos, endpos -begpos); cont.push_back(ssubstr); //将分割的字符串存入容器当中 begpos = str.find_first_not_of(defstr, endpos+1); &#125; return size; &#125; template&lt;typename Container&gt; inline size_t stringtok(std::string&amp; str, Container&amp; cont, const std::string defstr = &quot; &quot;) &#123; cont.clear(); std::size_t size = 0; std::size_t length = str.length(); std::size_t begpos = 0; std::size_t endpos = 0; while (begpos &lt; length) &#123; size++; begpos = str.find_first_not_of(defstr,begpos); if (begpos == std::string::npos) return -1; endpos = str.find_first_of(defstr, begpos); if (endpos == std::string::npos) &#123; endpos = length; &#125; string ssubstr = str.substr(begpos, endpos - begpos); cont.push_back(ssubstr); begpos = endpos + 1; &#125; return size; &#125;&#125;int main()&#123; string str = &quot;- This, a sample string.&quot;; vector&lt;string&gt; vec; int size = strg::strtok(str,vec,&quot;-,. &quot;); for (auto&amp; it : vec) cout &lt;&lt; it &lt;&lt; &quot; &quot;; cout&lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;而我今天主要想说的是另一个巧妙的方法：用一个小变量temp来中转:123456789101112131415161718192021int main()&#123; string str; int x = 0; int y = 0; cin&gt;&gt;str; int s = str.length(); int temp = 0; for(int i = 0; i&lt;s; i++) &#123; if(str[i] != &apos;#&apos;) &#123; temp = temp * 10 + (int)str[i] -48; &#125; else &#123; x = temp; temp = 0; &#125; &#125;y = temp;这样如果你想输入1#2，它就会通过temp中转后分别赋值给x=1和y=2，这个例子仅是转换为想要的数值int型。","categories":[{"name":"First","slug":"First","permalink":"https://blog.qihaoqiang.cn/categories/First/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"格式化输入","slug":"格式化输入","permalink":"https://blog.qihaoqiang.cn/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5/"},{"name":"分割字符串","slug":"分割字符串","permalink":"https://blog.qihaoqiang.cn/tags/%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"第一次测试尝试！","slug":"First","date":"2019-10-16T13:34:46.488Z","updated":"2019-12-06T07:54:03.409Z","comments":true,"path":"post/4ef2f023.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/4ef2f023.html","excerpt":"QHQ-This is a nice day","text":"QHQ-This is a nice dayWhy Blog对博客的理解喜欢写Blog的人，会经历三个阶段。第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。我们每个人的在网络上产生的数据越来越多，这些信息是我们在互联网上存在过的痕迹，值得我们认真对待。但是它们被分散分布在各个网站上。很多时候我们很难将它们聚合在一起，而且各个网站的信息排布方式也没有办法自由控制，所以我们需要一个可以由自己主宰的空间——博客。通过博客，我们可以记录自己的生活和成长的轨迹。它不像 Twitter 那样碎片化，也不像 Facebook 那样关系化，它是私人的空间。关于巴尔巴尔郝图 是小柒（戚浩强）的个人站。一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。TablesAreCoolcol 3 isright-aligned$1600col 2 iscentered$12zebra stripesare neat$1","categories":[{"name":"First","slug":"First","permalink":"https://blog.qihaoqiang.cn/categories/First/"}],"tags":[{"name":"First","slug":"First","permalink":"https://blog.qihaoqiang.cn/tags/First/"},{"name":"Second","slug":"Second","permalink":"https://blog.qihaoqiang.cn/tags/Second/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-16T09:56:10.900Z","updated":"2019-12-06T07:54:12.759Z","comments":true,"path":"post/4a17b156.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]}]}