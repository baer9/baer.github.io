{"meta":{"title":"Blog-Q","subtitle":null,"description":null,"author":"戚浩强","url":"https://qihaoqiang.github.io","root":"/"},"pages":[],"posts":[{"title":"关于Hexo主题的一些踩过的坑","slug":"关于Hexo主题的一些踩过的坑","date":"2019-11-24T05:48:07.341Z","updated":"2019-11-24T13:08:43.192Z","comments":true,"path":"2019/11/24/关于Hexo主题的一些踩过的坑/","link":"","permalink":"https://qihaoqiang.github.io/2019/11/24/%E5%85%B3%E4%BA%8EHexo%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/","excerpt":"","text":"Hexo主题的一些踩过的坑一、主题选择问题 首先你需要在官网hexo选择你喜欢的主题。主要下载步骤有：Hxeo+Github pages。 二、绑定域名问题 每一次推送都会把你在setting设置的域名给覆盖，让你每一次都需要重新绑定一些域名，很麻烦。 所以我就上网搜索与尝试，找到解决方法，首先在你hexo根目录找到source*目录，先新建.txt文件，在里面写入你要绑定的域名。再重命名为CNAME*，删除后缀名。使其没有后缀名，类型为文件。 然后在github的setting里设置一次（保险设置一次，不设置也行）。 三、主题内容更改 在这只说一些我自己碰到的，基本上一般的坑网上都有详细教程。 3.1、标题，作者和文字的更换​ 基本上在hexo*的根目录下的_config.yml*文件就可以更改了。 注意：冒号后面需要空一格，不然会报错。默认语言为en，中文为zh—CN（有需要可以更改，一般不变）。 3.2、js特效的更换添加​ 比如我的添加点击显示文字的特效： ​ 以我选择miho主题为例，先添加点击显示文字的js（目录为..\\themes\\miho\\source\\js\\click_show_text.js）click_show_text.js： 12345678910111213141516171819202122232425262728293031323334var a_idx = 0;jQuery(document).ready(function($) &#123; $(&quot;body&quot;).click(function(e) &#123; var a = new Array (&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);//文字自己填写所想要的 var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; &quot;z-index&quot;: 5, &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;#FF0000&quot; &#125;); $(&quot;body&quot;).append($i); $i.animate(&#123; &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 &#125;, 3000, function() &#123; $i.remove(); &#125;); &#125;); setTimeout(&apos;delay()&apos;, 2000);&#125;);function delay() &#123; $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;);&#125; ​ 然后需要在..\\themes\\miho\\layout\\layout.ejs添加语句： ` &lt;!--单击显示文字--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/click_show_text.js&quot;&gt;&lt;/script&gt; `​ 网上可以搜索自己喜欢的类型，步骤一样。 未完待续","categories":[],"tags":[]},{"title":"bat批修改文件后缀名","slug":"bat简单批文件操作","date":"2019-11-10T16:00:00.000Z","updated":"2019-11-11T03:39:47.815Z","comments":true,"path":"2019/11/11/bat简单批文件操作/","link":"","permalink":"https://qihaoqiang.github.io/2019/11/11/bat%E7%AE%80%E5%8D%95%E6%89%B9%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"今天先说说bat最简单的操作1ren *.jpg *.txt 此语句可以把当前文件夹的所有jpg照片转换为txt格式，（有利于隐藏照片哦）。 接下来就简单来说一下怎么具体操作吧 新建txt文本 在里面填写上面语句 修改txt后缀名为bat 提示：.jpg 意思是任意文件名的jpg格式，当然也可以.* ，表示任意文件文件格式，第二个*.txt意思是任意任意文件名的最终格式。就是原文件名不变，只修改后缀名。（后缀名可以根据自己的要求自己更改）。 未完待续。。。","categories":[{"name":"bat","slug":"bat","permalink":"https://qihaoqiang.github.io/categories/bat/"}],"tags":[{"name":"bat","slug":"bat","permalink":"https://qihaoqiang.github.io/tags/bat/"},{"name":"文件后缀名修改","slug":"文件后缀名修改","permalink":"https://qihaoqiang.github.io/tags/%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%E4%BF%AE%E6%94%B9/"},{"name":"显示文件后缀名","slug":"显示文件后缀名","permalink":"https://qihaoqiang.github.io/tags/%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/"}]},{"title":"C++半数集问题","slug":"半数集","date":"2019-10-25T04:38:19.040Z","updated":"2019-10-25T04:40:38.721Z","comments":true,"path":"2019/10/25/半数集/","link":"","permalink":"https://qihaoqiang.github.io/2019/10/25/%E5%8D%8A%E6%95%B0%E9%9B%86/","excerpt":"QHQ-【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下： （1）n∈set(n); （2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半； （3）按此规则进行处理，直到不能再添加自然数为止。","text":"QHQ-【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下： （1）n∈set(n); （2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半； （3）按此规则进行处理，直到不能再添加自然数为止。 12345678910111213141516171819【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：（1）n∈set(n);（2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；（3）按此规则进行处理，直到不能再添加自然数为止。例如，set(6)=&#123;6,16,26,126,36,136&#125;。半数集set（6）中有6个元素。注意，该半数集是多重集。【算法设计】对于给定的自然数n，计算半数集set(n)中的元素个数。【输入形式】只有1行，给出整数n（0&lt;n&lt;1000）。【输出形式】只有1行，给出半数集set(n)中的元素个数。【样例输入】6【样例输出】6 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int my_set(int n)&#123; int set_count = 1; if (n == 1) return 1; else &#123; int i = 1; while (i &lt;= (n / 2)) &#123; set_count = set_count + my_set(i); i++; &#125; return set_count; &#125;&#125;int main()&#123; int n = 0; cin &gt;&gt; n; cout &lt;&lt; my_set(n);&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://qihaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"半数集问题","slug":"半数集问题","permalink":"https://qihaoqiang.github.io/tags/%E5%8D%8A%E6%95%B0%E9%9B%86%E9%97%AE%E9%A2%98/"}]},{"title":"C++众数问题","slug":"众数问题","date":"2019-10-21T14:17:31.943Z","updated":"2019-10-21T13:11:18.440Z","comments":true,"path":"2019/10/21/众数问题/","link":"","permalink":"https://qihaoqiang.github.io/2019/10/21/%E4%BC%97%E6%95%B0%E9%97%AE%E9%A2%98/","excerpt":"QHQ-【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。","text":"QHQ-【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。 12345678910111213141516171819202122232425262728【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S=&#123;1,2,2,2,3,5&#125;。多重数S的众数是2，其重数为3 。【算法设计】对于给定的由n个自然数组成的多重集S，计算S的众数及其重数。【输入形式】第1行为多重数集S中元素个数n；接下来的n行中，每行有一个自然数。【输出形式】输出文件有2行，第1行是众数，第2行是重数。【样例输入】6122235【样例输出】23 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; #define MAXINT 10000 int main()&#123; int n = 0; cin &gt;&gt; n; int a[MAXINT] = &#123; 0 &#125;; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + n); int maxcount = 0; int maxcount_index = 0; int temp = 1; int b[MAXINT] = &#123; 0 &#125;; b[0] = a[0]; int b_index = 1; bool flag = false; for (int i = 0; i &lt; (n - 1); i++) &#123; if (a[i] != a[i + 1]) &#123; b[b_index++] = a[i + 1]; flag = true; &#125; else temp++; if (maxcount &lt; temp) &#123; maxcount = temp; maxcount_index = (b_index - 1); &#125; if (flag) &#123; temp = 1; flag = false; &#125; &#125; cout &lt;&lt; b[maxcount_index] &lt;&lt; endl; cout &lt;&lt; maxcount;&#125; Sort() 数组排列函数。用法 1、sort函数可以三个参数也可以两个参数，必须的头文件#include &lt; algorithm&gt;和using namespace std; 2、它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n) 3、Sort函数有三个参数：（第三个参数可不写） （1）第一个是要排序的数组的起始地址。 （2）第二个是结束的地址（最后一位要排序的地址） （3）第三个参数是排序的方法，可以是从大到小也可是从小到&gt;大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。 两个参数用法1234567891011121314 #include &lt;iostream&gt; #include &lt;algorithm&gt; int main() &#123; int a[20]=&#123;2,4,1,23,5,76,0,43,24,65&#125;,i; for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+20); for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0; &#125; ``` &gt; 输出结果是升序排列。（两个参数的sort默认升序排序） 12---##三个参数 // sort algorithm example#include #include #include using namespace std; bool myfunction (int i,int j) { return (i&lt;j); }//升序排列bool myfunction2 (int i,int j) { return (i&gt;j); }//降序排列 struct myclass { bool operator() (int i,int j) { return (i&lt;j);}} myobject; int main () { int myints[8] = {32,71,12,45,26,80,53,33}; vector myvector (myints, myints+8); // 32 71 12 45 26 80 53 33 // using default comparison (operator &lt;): sort (myvector.begin(), myvector.begin()+4); //(12 32 45 71)26 80 53 33 // using function as comp sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80) //std::sort (myints,myints+8,myfunction);不用vector的用法 // using object as comp sort (myvector.begin(), myvector.end(), myobject); //(12 26 32 33 45 53 71 80) // print out content: cout &lt;&lt; “myvector contains:”; for (std::vector::iterator it=myvector.begin(); it!=myvector.end(); ++it)//输出 cout &lt;&lt; ‘ ‘ &lt;&lt; *it; cout &lt;&lt; ‘\\n’; return 0;} 12---## string 使用反向迭代器来完成逆序排列 #include using namespace std;int main(){ string str(“cvicses”); string s(str.rbegin(),str.rend()); cout &lt;&lt; s &lt;&lt;endl; return 0;}//输出：sescivc```","categories":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://qihaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"众数问题","slug":"众数问题","permalink":"https://qihaoqiang.github.io/tags/%E4%BC%97%E6%95%B0%E9%97%AE%E9%A2%98/"}]},{"title":"C++金币阵列","slug":"金币阵列","date":"2019-10-21T12:26:55.162Z","updated":"2019-10-21T12:39:21.824Z","comments":true,"path":"2019/10/21/金币阵列/","link":"","permalink":"https://qihaoqiang.github.io/2019/10/21/%E9%87%91%E5%B8%81%E9%98%B5%E5%88%97/","excerpt":"QHQ-【问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上，1表示金币背面朝上。 金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。 算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。","text":"QHQ-【问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上，1表示金币背面朝上。 金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。 算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。 1234567891011121314151617181920212223242526问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上， 1表示金币背面朝上。金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。【输入形式】第1行有2个正整数m和n，用#隔开。以下m行是金币阵列的初始状态，每行有n个数字表示该行金币的状态，0表示正面朝上，1表示背面朝上。接着的m行是金币阵列的目标状态，不用#隔开 。【输出形式】输出计算出的最小变化次数。相应数据无解是，输出-1 。【样例输入】4#3101000110101101111011101【样例输出】2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;const int size1 = 100;int k, n, m, ccount, best;int b0[size1 + 1][size1 + 1], b1[size1 + 1][size1 + 1], b[size1 + 1][size1 + 1];bool found;void stringToInt(string str,int&amp; n,int&amp; m)&#123; int len = str.length(); int temp = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] != &apos;#&apos;) &#123; temp = temp * 10 + (int)str[i] - 48; &#125; else &#123; n = temp; temp = 0; &#125; &#125; m = temp;&#125;void trans1(int x) // 行翻转&#123; for (int i = 1; i &lt;= m; i++) b1[x][i] = b1[x][i] ^ 1; ccount++;&#125;void trans2(int x, int y) // 列交换&#123; for (int i = 1; i &lt;= n; i++) swap(b1[i][x], b1[i][y]); if (x != y) ccount++;&#125;bool same(int x, int y)&#123; for (int i = 1; i &lt;= n; i++) if (b0[i][x] != b1[i][y]) return false; return true;&#125;void acpy(int a[size1 + 1][size1 + 1], int b[size1 + 1][size1 + 1])&#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[i][j] = b[i][j];&#125;void answer()&#123; int x, y, j, p; //cin &gt;&gt; n &gt;&gt; m; string str; int temp = 0; cin &gt;&gt; str; stringToInt(str, n, m); // 原状态 b0 for (x = 1; x &lt;= n; x++) &#123; cin &gt;&gt; temp; for (y = 1; y &lt;= m; y++) &#123; b0[x][y] = temp % 10; temp /= 10; //cin &gt;&gt; b0[x][y]; &#125; &#125; // 目标状态 b1 for (x = 1; x &lt;= n; x++) &#123; cin &gt;&gt; temp; for (int y = 1; y &lt;= m; y++) &#123; b1[x][y] = temp % 10; temp /= 10; //cin &gt;&gt; b1[x][y]; &#125; &#125; acpy(b, b1); best = m + n + 1; for (j = 1; j &lt;= m; j++) &#123; acpy(b1, b); ccount = 0; trans2(1, j); // 列变换 int p; for (p = 1; p &lt;= n; p++) if (b0[p][1] != b1[p][1]) trans1(p); // 行变换 for (p = 1; p &lt;= m; p++) //找列相等的（ b1 的 q 列和 b0 的 p 列相等） &#123; found = false; for (int q = p; q &lt;= m; q++) if (same(p, q)) &#123; trans2(p, q); found = true; break; &#125; if (!found) break; &#125; if (found &amp;&amp; ccount &lt; best) best = ccount; &#125; if (best &lt; m + n + 1) &#123; cout &lt;&lt; best &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; //&#125;&#125;int main()&#123; answer(); return 0;&#125; StringToint() 函数获取输入的特殊格式，并分发数据给行n，列m。 trans1() 和 trans2() 为行转换与列转换。","categories":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/tags/C/"},{"name":"金币阵列","slug":"金币阵列","permalink":"https://qihaoqiang.github.io/tags/%E9%87%91%E5%B8%81%E9%98%B5%E5%88%97/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://qihaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++最大间隙","slug":"最大间隙","date":"2019-10-21T11:49:44.984Z","updated":"2019-10-21T12:26:06.290Z","comments":true,"path":"2019/10/21/最大间隙/","link":"","permalink":"https://qihaoqiang.github.io/2019/10/21/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%99/","excerpt":"QHQ-【问题描述】给定n个实数x1,x2,…,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。","text":"QHQ-【问题描述】给定n个实数x1,x2,…,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。 12345678910111213【问题描述】给定n个实数x1,x2,...,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。算法设计：对于给定的n个实数x1,x2,...,xn，计算它们的最大间隙。（只有一位小数）【输入形式】第一行有1个正整数n（n不超过10），接下来的1行有n个实数x1,x2,...,xn，中间用空格隔开。【输出形式】输出找到的最大间隙【样例输入】52.3 3.1 7.5 1.5 6.3【样例输出】3.2（保留一位小数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;const int MAX = 200001;double num[MAX];bool run()&#123; int n; if (scanf_s(&quot;%d&quot;, &amp;n) == EOF) return false; int i; double max = 0.0, min = INT_MAX; for (i = 0; i &lt; n; i++) &#123; scanf_s(&quot;%lf&quot;, &amp;num[i]); if (num[i] &gt; max) max = num[i]; if (num[i] &lt; min) min = num[i]; &#125; int* cnt = new int[n]; double* low = new double[n]; double* high = new double[n]; for (i = 0; i &lt; n; i++) &#123; cnt[i] = 0; low[i] = max; high[i] = min; &#125; double ave = (max - min) / (n - 1); for (i = 0; i &lt; n; i++) &#123; int tmp = (int)((num[i] - min) / ave); cnt[tmp]++; if (num[i] &gt; high[tmp]) high[tmp] = num[i]; if (num[i] &lt; low[tmp]) low[tmp] = num[i]; &#125; double t = high[0], res = 0.0; for (i = 1; i &lt; n; i++) &#123; if (cnt[i] &gt; 0) &#123; double tmp = low[i] - t; if (tmp &gt; res) res = tmp; t = high[i]; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; res &lt;&lt; endl; return true;&#125;int main()&#123; while (run()); return 0;&#125; 因为我用的是vs2019，所以在scanf输出的时候会出现 C6031:返回值被忽略的问题：“scanf”，所以需要改写scanf为scanf_s。 题目要求结果有一位小数，在C++中，是没有格式符的，所以想起用setprecision() 函数，但是使用这个函数，需要在头文件引入 #include，使用方式在此再简单回顾一下： 1cout &lt;&lt; setprecision(2) &lt;&lt; res &lt;&lt;endl; 这是保留小数点后两位（但是如果结果是整数则是整数，不自动 补零） 1cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; res &lt;&lt; endl; 在前面加上 fixed 就可以自动补零。 3.再次附一个小吕哥的源码： 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define MAXINT 100000using namespace std;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; endl; double a[MAXINT] = &#123;0.0 &#125;; for(int i = 0;i &lt; n;i++)&#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n); double maxsub = 0.0; double temp = 0.0; for(int i = 0;i &lt; (n - 1);i++)&#123; temp = fabs(a[i] - a[i + 1]); if(maxsub &lt; temp)&#123; maxsub = temp; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; maxsub;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://qihaoqiang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"最大间隙","slug":"最大间隙","permalink":"https://qihaoqiang.github.io/tags/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%99/"},{"name":"C++格式化输出","slug":"C-格式化输出","permalink":"https://qihaoqiang.github.io/tags/C-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"}]},{"title":"2019Vs建立C++项目","slug":"2019Vs建立C++项目","date":"2019-10-19T09:44:51.024Z","updated":"2019-10-19T09:44:51.024Z","comments":true,"path":"2019/10/19/2019Vs建立C++项目/","link":"","permalink":"https://qihaoqiang.github.io/2019/10/19/2019Vs%E5%BB%BA%E7%AB%8BC++%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"C++分割输入字符串","slug":"C++格式化输入","date":"2019-10-17T15:13:42.687Z","updated":"2019-11-23T14:14:58.641Z","comments":true,"path":"2019/10/17/C++格式化输入/","link":"","permalink":"https://qihaoqiang.github.io/2019/10/17/C++%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5/","excerpt":"QHQ-It was day full of memories","text":"QHQ-It was day full of memories C++字符串分割C++没有split分割的函数！！！！ C++没有c语言的那样方便的格式化输入，像c语言你如果想一次性输入1#2，而分别把1和2赋值给x和y，你可以这样： 1scanf(&quot;%d#%d&quot;,&amp;x,&amp;y);当然你也可以自己定义一个方法来实现这个想法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstddef&gt;#include &lt;vector&gt;using namespace std;namespace strg&#123; //函数模板 template&lt;typename Container&gt; inline std::size_t strtok(std::string&amp; str, Container&amp; cont, const std::string defstr = &quot; &quot;) &#123; cont.clear(); std::size_t size = 0; std::size_t begpos = 0 ; std::size_t endpos = 0 ; begpos = str.find_first_not_of(defstr); while (begpos != std::string::npos) &#123; size++; endpos = str.find_first_of(defstr, begpos); if (endpos == std::string::npos) &#123; endpos = str.size(); &#125; string ssubstr = str.substr(begpos, endpos -begpos); cont.push_back(ssubstr); //将分割的字符串存入容器当中 begpos = str.find_first_not_of(defstr, endpos+1); &#125; return size; &#125; template&lt;typename Container&gt; inline size_t stringtok(std::string&amp; str, Container&amp; cont, const std::string defstr = &quot; &quot;) &#123; cont.clear(); std::size_t size = 0; std::size_t length = str.length(); std::size_t begpos = 0; std::size_t endpos = 0; while (begpos &lt; length) &#123; size++; begpos = str.find_first_not_of(defstr,begpos); if (begpos == std::string::npos) return -1; endpos = str.find_first_of(defstr, begpos); if (endpos == std::string::npos) &#123; endpos = length; &#125; string ssubstr = str.substr(begpos, endpos - begpos); cont.push_back(ssubstr); begpos = endpos + 1; &#125; return size; &#125;&#125;int main()&#123; string str = &quot;- This, a sample string.&quot;; vector&lt;string&gt; vec; int size = strg::strtok(str,vec,&quot;-,. &quot;); for (auto&amp; it : vec) cout &lt;&lt; it &lt;&lt; &quot; &quot;; cout&lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 而我今天主要想说的是另一个巧妙的方法：用一个小变量temp来中转: 123456789101112131415161718192021int main()&#123; string str; int x = 0; int y = 0; cin&gt;&gt;str; int s = str.length(); int temp = 0; for(int i = 0; i&lt;s; i++) &#123; if(str[i] != &apos;#&apos;) &#123; temp = temp * 10 + (int)str[i] -48; &#125; else &#123; x = temp; temp = 0; &#125; &#125;y = temp; 这样如果你想输入1#2，它就会通过temp中转后分别赋值给x=1和y=2，这个例子仅是转换为想要的数值int型。","categories":[{"name":"First","slug":"First","permalink":"https://qihaoqiang.github.io/categories/First/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://qihaoqiang.github.io/tags/C/"},{"name":"格式化输入","slug":"格式化输入","permalink":"https://qihaoqiang.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5/"},{"name":"分割字符串","slug":"分割字符串","permalink":"https://qihaoqiang.github.io/tags/%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"第一次测试尝试！","slug":"First","date":"2019-10-16T13:34:46.488Z","updated":"2019-10-18T15:29:45.018Z","comments":true,"path":"2019/10/16/First/","link":"","permalink":"https://qihaoqiang.github.io/2019/10/16/First/","excerpt":"QHQ-This is a nice day","text":"QHQ-This is a nice day Why Blog对博客的理解喜欢写Blog的人，会经历三个阶段。 第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我们每个人的在网络上产生的数据越来越多，这些信息是我们在互联网上存在过的痕迹，值得我们认真对待。但是它们被分散分布在各个网站上。很多时候我们很难将它们聚合在一起，而且各个网站的信息排布方式也没有办法自由控制，所以我们需要一个可以由自己主宰的空间——博客。 通过博客，我们可以记录自己的生活和成长的轨迹。它不像 Twitter 那样碎片化，也不像 Facebook 那样关系化，它是私人的空间。 关于巴尔巴尔郝图 是小柒（戚浩强）的个人站。 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1","categories":[{"name":"First","slug":"First","permalink":"https://qihaoqiang.github.io/categories/First/"}],"tags":[{"name":"First","slug":"First","permalink":"https://qihaoqiang.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"https://qihaoqiang.github.io/tags/Second/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-16T09:56:10.900Z","updated":"2019-10-16T09:56:10.900Z","comments":true,"path":"2019/10/16/hello-world/","link":"","permalink":"https://qihaoqiang.github.io/2019/10/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}