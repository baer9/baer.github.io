{"meta":{"title":"Blog-Q","subtitle":null,"description":null,"author":"戚浩强","url":"https://blog.qihaoqiang.cn","root":"/"},"pages":[],"posts":[{"title":"幸会-1988","slug":"幸会-1988","date":"2020-04-07T06:11:52.000Z","updated":"2020-04-07T13:20:42.252Z","comments":true,"path":"post/85e9e91e.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/85e9e91e.html","excerpt":"QHQ-【问题描述】","text":"QHQ-【问题描述】","categories":[],"tags":[]},{"title":"3D地球统计","slug":"3D地球统计","date":"2020-03-27T10:07:35.000Z","updated":"2020-03-27T10:26:39.243Z","comments":true,"path":"post/810db7b7.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/810db7b7.html","excerpt":"QHQ-【问题描述】3D炫酷的地球统计js","text":"QHQ-【问题描述】3D炫酷的地球统计js3D炫酷的地球统计js.地址→ https://www.revolvermaps.com/?target=setupgl(个人推荐)比https://www.revolvermaps.com/?target=setup选择多一点.可以直接复制这代码在你网站中,也可以在下面设置一个不一样的,这个是3D的,你也可以选择2D的.&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/6.js?i=5d0cxgexeci&amp;amp;m=1&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=0&quot; async=&quot;async&quot;&gt;&lt;/script&gt;汉化","categories":[],"tags":[]},{"title":"Living","slug":"Living","date":"2020-03-27T09:18:09.000Z","updated":"2020-03-30T09:46:10.977Z","comments":true,"path":"post/7c80c3b5.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/7c80c3b5.html","excerpt":"QHQ-【问题描述】无","text":"QHQ-【问题描述】无","categories":[],"tags":[]},{"title":"nginx超详细配置及中文解释","slug":"nginx超详细配置","date":"2020-02-15T12:58:23.000Z","updated":"2020-02-15T14:32:47.061Z","comments":true,"path":"post/c07eb030.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/c07eb030.html","excerpt":"QHQ-【问题描述】Nginx的配置文件详解（超详细）","text":"QHQ-【问题描述】Nginx的配置文件详解（超详细）1、安装Nginx在安装Nginx之前，需确保系统已经安装了gcc、 openssl-devel、 pcre-devel和zlib-devel软件库。下面是Nginx安装过程：123456wget http://nginx.org/download/nginx-1.0.14.tar.gztar zxvf nginx-1.0.14.tar.gz./configure --with-http_stub_status_module --prefix=/opt/nginxcd nginx-1.0.14makemake installwget http://nginx.org/download/nginx-1.0.14.tar.gztar zxvf nginx-1.0.14.tar.gz./configure --with-http_stub_status_module --prefix=/opt/nginxcd nginx-1.0.14makemake install其中， –with-http_stub_status_module 可以用来启用 Nginx 的 NginxStatus 功能，以监控 Nginx 的运行状态。想要了解更多的模块的情况可以通过 ./configure –help 选项查看。2、Nginx的配置文件结构Nginx的配置文件nginx.conf位于其安装目录的conf目录下。nginx.conf由多个块组成，最外面的块是main，main包含Events和HTTP，HTTP包含upstream和多个Server，Server又包含多个location：main（全局设置）、server（主机设置）、upstream（负载均衡服务器设置）和 location（URL匹配特定位置的设置）。main块设置的指令将影响其他所有设置；server块的指令主要用于指定主机和端口；upstream指令主要用于负载均衡，设置一系列的后端服务器；location块用于匹配网页位置。这四者之间的关系式：server继承main，location继承server，upstream既不会继承其他设置也不会被继承。在这四个部分当中，每个部分都包含若干指令，这些指令主要包含Nginx的主模块指令、事件模块指令、HTTP核心模块指令，同时每个部分还可以使用其他HTTP模块指令，例如Http SSL模块、HttpGzip Static模块和Http Addition模块等。2.1 Nginx的全局配置代码如下：12345678910user nobody nobody;worker_processes 2;error_log logs/error.log notice;pid logs/nginx.pid;worker_rlimit_nofile 65535;events&#123;use epoll;worker_connections 65536;&#125;每个配置选项的含义解释如下：user是个主模块指令，指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。worker_processes是个主模块指令，指定了Nginx要开启的进程数。每个Nginx进程平均耗费10M~12M内存。建议指定和CPU的数量一致即可。error_log是个主模块指令，用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。pid是个主模块指令，用来指定进程pid的存储文件位置。worker_rlimit_nofile用于绑定worker进程和CPU， Linux内核2.4以上可用。events事件指令是设定Nginx的工作模式及连接数上限：use是个事件模块指令，用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中。对于Linux系统，epoll工作模式是首选。worker_connections也是个事件模块指令，用于定义Nginx每个进程的最大连接数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_client=worker_processes*worker_connections。在作为反向代理时，max_clients变为：max_clients = worker_processes * worker_connections/4。进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效2.2 HTTP服务器配置Nginx对HTTP服务器相关属性的配置代码如下：123456789101112131415161718192021http&#123;include conf/mime.types;default_type application/octet-stream;log_format main &apos;$remote_addr - $remote_user [$time_local] &apos;&apos;&quot;$request&quot; $status $bytes_sent &apos;&apos;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos;&apos;&quot;$gzip_ratio&quot;&apos;;log_format download &apos;$remote_addr - $remote_user [$time_local] &apos;&apos;&quot;$request&quot; $status $bytes_sent &apos;&apos;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &apos;&apos;&quot;$http_range&quot; &quot;$sent_http_content_range&quot;&apos;;client_max_body_size 20m;client_header_buffer_size 32K;large_client_header_buffers 4 32k;Sendfile on;tcp_nopush on;tcp_nodelay on;keepalive_timeout 60;client_header_timeout 10;client_body_timeout 10;send_timeout 10;下面详细介绍下这段代码中每个配置选项的含义。include是个主模块指令，实现对配置文件所包含的文件的设定，可以减少主配置文件的复杂度。类似于Apache中的include方法。default_type属于HTTP核心模块指令，这里设定默认类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置PHP环境时，Nginx是不予解析的，此时，用浏览器访问PHP文件就会出现下载窗口。下面的代码实现对日志格式的设定：12345678log_format main '$remote_addr - $remote_user [$time_local] ''\"$request\" $status $bytes_sent ''\"$http_referer\" \"$http_user_agent\" ''\"$gzip_ratio\"';log_format download '$remote_addr - $remote_user [$time_local] ''\"$request\" $status $bytes_sent ''\"$http_referer\" \"$http_user_agent\" ''\"$http_range\" \"$sent_http_content_range\"';log_format是Nginx的HttpLog模块指令，用于指定Nginx日志的输出格式。main为此日志输出格式的名称，可以在下面的access_log指令中引用。client_max_body_size用来设置允许客户端请求的最大的单个文件字节数；client_header_buffer_size用于指定来自客户端请求头的headerbuffer大小。对于大多数请求，1K的缓冲区大小已经足够，如果自定义了消息头或有更大的Cookie，可以增加缓冲区大小。这里设置为32K；large_client_header_buffers用来指定客户端请求中较大的消息头的缓存最大数量和大小， “4”为个数，“128K”为大小，最大缓存量为4个128K；sendfile参数用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞；keepalive_timeout设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接；client_header_timeout设置客户端请求头读取超时时间。如果超过这个时间，客户端还没有发送任何数据，Nginx将返回“Request time out（408）”错误；client_body_timeout设置客户端请求主体读取超时时间。如果超过这个时间，客户端还没有发送任何数据，Nginx将返回“Request time out（408）”错误，默认值是60；send_timeout指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。2.3 HttpGzip模块配置下面配置Nginx的HttpGzip模块。这个模块支持在线实时压缩输出数据流。看是否安装了HttpGzip模块：1234[root@qi ~]# /opt/nginx/sbin/nginx -V （注意V是大写）nginx version: nginx/1.0.14built by gcc 4.4.6 20110731 (Red Hat 4.4.6-3) (GCC)configure arguments: --with-http_stub_status_module --with-http_gzip_static_module --prefix=/opt/nginx通过/opt/nginx/sbin/nginx -V命令可以查看安装Nginx时的编译选项，由输出可知，我们已经安装了HttpGzip模块。下面是HttpGzip模块在Nginx配置中的相关属性设置：1234567gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_http_version 1.1;gzip_comp_level 2;gzip_types text/plain application/x-javascript text/css application/xml;gzip_vary on;gzip用于设置开启或者关闭gzip模块，“gzip on”表示开启GZIP压缩，实时压缩输出数据流；gzip_min_length设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取。默认值是0，不管页面多大都进行压缩。建议设置成大于1K的字节数，小于1K可能会越压越大；gzip_buffers表示申请4个单位为16K的内存作为压缩结果流缓存，默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果；gzip_http_version用于设置识别HTTP协议版本，默认是1.1，目前大部分浏览器已经支持GZIP解压，使用默认即可；gzip_comp_level用来指定GZIP压缩比，1 压缩比最小，处理速度最快；9 压缩比最大，传输速度快，但处理最慢，也比较消耗cpu资源；gzip_types用来指定压缩的类型，无论是否指定，“text/html”类型总是会被压缩的；gzip_vary选项可以让前端的缓存服务器缓存经过GZIP压缩的页面，例如用Squid缓存经过Nginx压缩的数据。2.4 负载均衡配置 负载均衡下面设定负载均衡的服务器列表：1234567upstream cszhi.com&#123;ip_hash;server 192.168.8.11:80;server 192.168.8.12:80 down;server 192.168.8.13:8009 max_fails=3 fail_timeout=20s;server 192.168.8.146:8080;&#125;upstream是Nginx的HTTP Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。在上面的设定中，通过upstream指令指定了一个负载均衡器的名称cszhi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。Nginx的负载均衡模块目前支持4种调度算法，下面进行分别介绍，其中后两项属于第三方的调度方法。轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响；Weight：指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下；ip_hash：每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题；fair：比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块；url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：down：表示当前的server暂时不参与负载均衡；backup：预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻；max_fails：允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误；fail_timeout：在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。注意，当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。2.5 server虚拟主机配置下面介绍对虚拟主机的配置。建议将对虚拟主机进行配置的内容写进另外一个文件，然后通过include指令包含进来，这样更便于维护和管理。1234567server&#123;listen 80;server_name www.lovefive.club lovefive.club;index index.html index.htm index.php;root /www/www.lovefive.clubcharset gb2312;access_log logs/www.ixdba.net.access.log main;server标志定义虚拟主机开始，listen用于指定虚拟主机的服务端口，server_name用来指定IP地址或者域名，多个域名之间用空格分 开。index用于设定访问的默认首页地址，root指令用于指定虚拟主机的网页根目录，这个目录可以是相对路径，也可以是绝对路径。Charset用于 设置网页的默认编码格式。access_log用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。2.6 location URL匹配配置URL地址匹配是进行Nginx配置中最灵活的部分。 location支持正则表达式匹配，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。使用location URL匹配配置还可以实现反向代理，用于实现PHP动态解析或者负载负载均衡。以下这段设置是通过location指令来对网页URL进行分析处理，所有扩展名以.gif、.jpg、.jpeg、.png、.bmp、.swf结尾的静态文件都交给nginx处理，而expires用来指定静态文件的过期时间，这里是30天。1234location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ &#123;root /web/www/www.lovefive.club;expires 30d;&#125;以下这段设置是将upload和html下的所有文件都交给nginx来处理，当然，upload和html目录包含在/web/www/www.lovefive.club目录中。1234location ~ ^/(upload|html)/ &#123;root /web/www/www.lovefive.club;expires 30d;&#125;在最后这段设置中，location是对此虚拟主机下动态网页的过滤处理，也就是将所有以.jsp为后缀的文件都交给本机的8080端口处理。1234location ~ .*.php$ &#123;index index.php;proxy_pass http://localhost:8080;&#125;2.7 StubStatus模块配置StubStatus模块能够获取Nginx自上次启动以来的工作状态，此模块非核心模块，需要在Nginx编译安装时手工指定才能使用此功能。以下指令实指定启用获取Nginx工作状态的功能。location /NginxStatus { stub_status on; access_log logs/NginxStatus.log; auth_basic \"NginxStatus\"; auth_basic_user_file ../htpasswd; } &lt;!--￼11--&gt; 然后输入两次密码后确认之后添加用户成功。要查看Nginx的运行状态，可以输入http://ip/NginxStatus，输入创建的用户名和密码就可以看到Nginx的运行状态：1234Active connections: 1server accepts handled requests34561 35731 354399Reading: 0 Writing: 3 Waiting: 0Active connections表示当前活跃的连接数，第三行的三个数字表示 Nginx当前总共处理了34561个连接， 成功创建次握手， 总共处理了354399个请求。最后一行的Reading表示Nginx读取到客户端Header信息数， Writing表示Nginx返回给客户端的Header信息数，“Waiting”表示Nginx已经处理完，正在等候下一次请求指令时的驻留连接数。在最后这段设置中，设置了虚拟主机的错误信息返回页面，通过error_page指令可以定制各种错误信息的返回页面。在默认情况下，Nginx会在主目录的html目录中查找指定的返回页面，特别需要注意的是，这些错误信息的返回页面大小一定要超过512K，否者会被ie浏览器替换为ie默认的错误页面。12345error_page 404 /404.html;error_page 500 502 503 504 /50x.html;location = /50x.html &#123;root html;&#125;参考一","categories":[],"tags":[]},{"title":"照片要启动gzip吗？","slug":"照片要启动gzip吗？","date":"2020-02-15T12:58:23.000Z","updated":"2020-02-15T14:32:47.061Z","comments":true,"path":"post/3e0fec4e.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/3e0fec4e.html","excerpt":"QHQ-【问题描述】图片要启用gzip压缩吗","text":"QHQ-【问题描述】图片要启用gzip压缩吗今天在细看nginx配置的时候，发现一个httpGzip模块，图片到底需不需要启用GZip压缩？我搜索一下并总结，图片是不需要启用GZip压缩的（我已经启动全站加速及压缩，完全没必要）。今天，我把此问题写作成文，给大家分析一下为什么图片不需要启用GZip压缩。图片启用GZip压缩会适得其反一些开发者使用HTTP压缩那些已经本地已经压缩过的文件，而这些已经压缩过的文件再次被GZip压缩时，是不能提高性能的，表现在如下两个方面。首先，HTTP压缩需要成本。Web服务器获得需要的内容，然后压缩它，最后将它发送到客户端。如果内容不能被进一步压缩，你只是在浪费CPU做无意义的任务。其次，采用HTTP压缩已经被过压缩的东西并不能使它更小。事实上，添加标头，压缩字典，并校验响应体实际上使它变得更大，如下图所示：HTTP压缩过程你的网站实际上是这样做的吗？是的，它比你想象的更常见。PNG图片启用GZip压缩的后果下面这张是启用GZip压缩的PNG图片，看看它的标头信息：PNG图片启用GZip压缩的后果不仅浪费了CPU，还增大了图片的体积，之前也写过一篇文章详细分析了《图片GZip压缩后体积变大》，这里再看看图片被GZip压缩的后果：GZip图片增大了体积用一句话来结论，那就是图片启用GZip压缩，不仅浪费了CPU，还增大了体积，势必影响服务器性能，影响网站速度。图片要启用gzip压缩吗？绝对不要！参考一","categories":[],"tags":[]},{"title":"什么是负载平衡？","slug":"什么是负载平衡","date":"2020-02-15T12:55:54.000Z","updated":"2020-02-15T14:32:47.061Z","comments":true,"path":"post/1e8d8275.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/1e8d8275.html","excerpt":"QHQ-【问题描述】什么是负载平衡？负载平衡有什么用？具体功能有什么？具体应用有？未来趋势会怎样？","text":"QHQ-【问题描述】什么是负载平衡？负载平衡有什么用？具体功能有什么？具体应用有？未来趋势会怎样？概述随着网络的出现，人们便开始频频使用各种智能设备进行各种精神享受，然而面对庞大的数据流量，各网站的访问十分集中，以致于网络服务器变得很拥挤、速度很慢。面对网络服务器岌岌可危的状况，相关科研人员针对该现象发明了负载均衡器，那么负载均衡器究竟有什么作用呢?接下来就让我们一起来了解关于负载均衡器的问题吧! 什么是负载均衡器顾名思义，负载均衡器主要采取高端技术――负载均衡技术，它可以利用该技术进行各种灵活的分配计算将全部的网络请求均衡地分布到其他服务器上，通过合理管理每天的网上数据流量来减轻单个服务器上的负担，力求达到使网络访问者享受最佳的联网体验。通俗的说： 负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。一个没有负载均衡的 web 架构类似下面这样：​ 在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。而通过在后端引入一个负载均衡器和至少一个额外的 web 服务器，可以缓解这个故障。通常情况下，所有的后端服务器会保证提供相同的内容，以便用户无论哪个服务器响应，都能收到一致的内容。 ​ 从图里可以看到，用户访问负载均衡器，再由负载均衡器将请求转发给后端服务器。在这种情况下，单点故障现在转移到负载均衡器上了。这里又可以通过引入第二个负载均衡器来缓解。负载均衡器的形式 负载均衡器的形式可谓是多种多样，除了单纯作为负载均衡器外，有些负载均衡器还可在交换设备中置于网络服务器和互联网之间，而还有的负载均衡器则利用网络适配器将该功能集成至PC当中。 负载均衡器的功能负载均衡器具有提供服务一致性的功能，负载均衡器通过读取客户端所发出请求内的信息，进行重写报头程序然后将请求发送至合适的服务器上，该服务器会维护着该客户端信息。在http通信当中，负载均衡器提供服务一致性的功能就得到了很好的发挥，但提供该服务的途径并不是非常安全。但若将消息加密后，负载均衡器就无法读取隐藏其中的信息了。当服务集群中的某个节点无法成功处理请求时，那么该请求就会被发往其他节点上去，当请求成功发至另一节点后，原节点上的请求信息就会自动消失了。由于所有的客户端请求都会先经过负载均衡器，所以负载均衡器具有统计计量的功能，利用该功能负载均衡器就可以准确统计出各阶段各种流量流动以及各项目进行的次数等，从而网络就可以适当调整系统性能了。负载均衡器可以处理什么样的请求？负载均衡器的管理员能主要为下面四种主要类型的请求设置转发规则：HTTPHTTPSTCPUDP负载均衡器如何选择要转发的后端服务器？负载均衡器一般根据两个因素来决定要将请求转发到哪个服务器。首先，确保所选择的服务器能够对请求做出响应，然后根据预先配置的规则从健康服务器池（healthy pool）中进行选择。因为，负载均衡器应当只选择能正常做出响应的后端服务器，因此就需要有一种判断后端服务器是否「健康」的方法。为了监视后台服务器的运行状况，运行状态检查服务会定期尝试使用转发规则定义的协议和端口去连接后端服务器。如果，服务器无法通过健康检查，就会从池中剔除，保证流量不会被转发到该服务器，直到其再次通过健康检查为止。负载均衡算法负载均衡算法决定了后端的哪些健康服务器会被选中。几个常用的算法：Round Robin（轮询）：为第一个请求选择列表中的第一个服务器，然后按顺序向下移动列表直到结尾，然后循环。Least Connections（最小连接）：优先选择连接数最少的服务器，在普遍会话较长的情况下推荐使用。Source：根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。负载均衡器的应用 对于网络各个核心部分数据流量增长迅速等问题，单一设备根本承担不住，所以为了加强处理能力，同时也为了提高资源利用，如今很多企业纷纷采取负载均衡技术，简单快捷，为自己的企业减掉很多不必要的麻烦。 如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器。可以通过 Source 算法基于客户端的 IP 信息创建关联，或者使用粘性会话（sticky sessions）。最后，想要解决负载均衡器的单点故障问题，可以将第二个负载均衡器连接到第一个上，从而形成一个集群。 当主负载均衡器发生了故障，就需要将用户请求转到第二个负载均衡器。因为 DNS 更改通常会较长的时间才能生效，因此需要能灵活解决 IP 地址重新映射的方法，比如浮动 IP（floating IP）。这样域名可以保持和相同的 IP 相关联，而 IP 本身则能在服务器之间移动。一个使用浮动 IP 的负载均衡架构示意图：负载均衡器的未来走势 时代发展的速度我们有目共睹，谁能猜想得到将来的事情呢?但是，随着科技越来越高端，网络数据必定呈上升趋势，所以负载均衡器在未来的生活中一定是必不可少的一种设备!参考一参考二","categories":[],"tags":[]},{"title":"实用网站推荐","slug":"实用网站推荐","date":"2020-02-14T04:00:11.000Z","updated":"2020-04-02T04:30:32.016Z","comments":true,"path":"post/6d4cd299.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/6d4cd299.html","excerpt":"QHQ-【问题描述】实用网站推荐！！!","text":"QHQ-【问题描述】实用网站推荐！！!如有不可用或失效，请留言联系，第一时间给予回复解决！一个刚上路的小菜鸟！名称链接(有部分需科学上网，在这不一一标明)个人喜爱级别AI智能图片放大🔗⭐⭐⭐⭐⭐word填入优美代码🔗⭐⭐⭐⭐⭐图片格式转换🔗⭐⭐⭐⭐⭐MSND，我告诉你🔗⭐⭐⭐⭐⭐图片壁纸P1🔗；P2🔗；P3🔗；P4🔗；⭐⭐⭐⭐⭐谷歌图片压缩🔗⭐⭐⭐⭐⭐文档比较🔗⭐⭐⭐⭐⭐新型肺炎数据(实时更新)🔗⭐⭐⭐⭐⭐太鼓达人🔗⭐⭐⭐⭐⭐临时手机验证码🔗⭐⭐⭐⭐⭐临时邮箱验证码🔗⭐⭐⭐⭐⭐AI捏人🔗⭐⭐⭐⭐⭐PPT模板P1🔗；P2🔗⭐⭐⭐⭐⭐默沙东手册🔗⭐⭐⭐⭐⭐词云🔗⭐⭐⭐⭐⭐中国慕课🔗⭐⭐⭐⭐⭐Everything搜索下载🔗⭐⭐⭐⭐大像素🔗⭐⭐⭐⭐emm🔗⭐⭐⭐⭐全网热门🔗⭐⭐⭐⭐全历史🔗⭐⭐⭐⭐云图片(自画)🔗⭐⭐⭐查询展会🔗⭐⭐⭐背景素材🔗⭐⭐⭐做(学)音乐🔗⭐⭐⭐新媒体导航🔗⭐⭐⭐老照片上色🔗⭐⭐⭐yes/no🔗⭐⭐⭐整数数列搜索🔗⭐⭐⭐数据表🔗⭐⭐⭐中国地图🔗⭐⭐⭐解谜游戏🔗⭐⭐⭐大佬网站🔗⭐⭐⭐人类测试🔗⭐⭐探月了解🔗⭐⭐音乐分轨🔗⭐⭐猫🔗⭐反人类UI🔗⭐物流🔗⭐地球时间🔗⭐","categories":[],"tags":[{"name":"网站","slug":"网站","permalink":"https://blog.qihaoqiang.cn/tags/%E7%BD%91%E7%AB%99/"},{"name":"实用工具","slug":"实用工具","permalink":"https://blog.qihaoqiang.cn/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"Windows下使用Everything搜索","slug":"Windows下使用Everything搜索","date":"2020-02-09T02:10:13.000Z","updated":"2020-02-15T14:32:47.061Z","comments":true,"path":"post/4ccaf67c.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/4ccaf67c.html","excerpt":"QHQ-【问题描述】全局搜索文件，无内存占据，方便快捷搜索（即时搜索），可集成右键快捷，也可创建组合快捷键。","text":"QHQ-【问题描述】全局搜索文件，无内存占据，方便快捷搜索（即时搜索），可集成右键快捷，也可创建组合快捷键。Everything的下载安装教程（附带快捷设置）安装文件夹可按自己意愿更改。第一个保存设置和数据文件不需要更改设置，NTFS索引选择以管理员身份运行。Everything快捷键的一些设置。集成到鼠标右键。设置组合快捷键。","categories":[],"tags":[]},{"title":"apache和nginx简单区分","slug":"apache和nginx简单区分","date":"2020-01-14T10:44:12.000Z","updated":"2020-01-15T06:27:44.918Z","comments":true,"path":"post/4c8dcffc.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/4c8dcffc.html","excerpt":"QHQ-【问题描述】web服务器该选择apache还是nginx","text":"QHQ-【问题描述】web服务器该选择apache还是nginx\\一、apache与nginx的区别：**​ 1、二者最核心的区别在于apache是同步多进程模型，一个连接对应一个进程；nginx是异步的，多个连接（万级别）可以对应一个进程 。nginx处理静态文件好,耗费内存少.但无疑apache仍然是目前的主流,有很多丰富的特性.所以还需要搭配着来.当然如果能确定nginx就适合需求,那么使用nginx会是更经济的方式。​ 2、nginx的负载能力比apache高很多。最新的服务器也改用nginx了。而且nginx改完配置能-t测试一下配置有没 有问题。​ 3、apache重启的时候发现配置出错了，会很崩溃，改的时候都会非常小心翼翼现在看有好多集群站，前端nginx抗并发，后端apache集群， 配合的也不错。​ 4、nginx处理动态请求是鸡肋，一般动态请求要apache去做，nginx只适合静态和反向。​ 5、从经验来看，nginx是很不错的前端服务器，负载性能很好，nginx，用webbench模拟10000个静态文件请求毫不吃力。 apache对php等语言的支持很好，此外apache有强大的支持网络，发展时间相对nginx更久，bug少但是apache有先天不支持多核心处理负载鸡肋的缺点，建议使用nginx做前端，后端用apache。大型网站建议用nginx自代的集群功能。​ 6、大部分情况下nginx都优于APACHE，比如说静态文件处理、PHP-CGI的支持、反向代理功能、前端 Cache、维持连接等等。在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出现Apache进程数 飙升，从而拒绝服务的现象。​ 7、Apache在处理动态有优势，Nginx并发性比较好，CPU内存占用低，如果rewrite频繁，那还是Apache吧！​ 8、一般来说，需要性能的web 服务，用nginx 。如果不需要性能只求稳定，那就apache 吧。二、apache与nginx优缺点比较1、nginx相对于apache的优点：轻量级，同样web 服务，比apache 占用更少的内存及资源 ；抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 ；高度模块化的设计，编写模块相对简单 ；社区活跃，各种高性能模块出品迅速啊 ；Nginx本身就是一个反向代理服务器 ，Nginx支持7层负载均衡；Nginx可能会比apache支持更高的并发，nginx配置文件写的很简洁，正则配置让很多事情变得简单运行效率高，占用资源少，代理功能强大，很适合做前端响应服务器 ！2、apache 相对于nginx 的优点：rewrite ，比nginx 的rewrite 强大 ；模块超多，基本想到的都可以找到 ；少bug ，nginx 的bug 相对较多 ；超稳定 ，Aapche依然是大部分公司的首先，因为其成熟的技术和开发社区已经 也是非常不错的性能。\\三、为什么现在 Nginx 才是 Web 服务器的首选**作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。在高连接并发的情况下，Nginx是Apache服务器不错的替代品: Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一. 能够支持高达 50,000 个并发连接数的响应, 感谢Nginx为我们选择了 epoll and kqueue 作为开发模型.Nginx作为负载均衡服务器: Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务, 也可以支持作为 HTTP代理 服务器对外进行服务. Nginx采用C进行编写, 不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多.​ 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器）, Last.fm 描述了成功并且美妙的使用经验.​ Nginx 是一个安装非常的简单 , 配置文件非常简洁（还能够支持perl语法）, Bugs 非常少的服务器: Nginx 启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动. 你还能够不间断服务的情况下进行软件版本的升级 .​ Nginx 配置简洁, Apache 复杂 ， Nginx 静态处理性能比 Apache 高 3倍以上 ， Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端用， Apache 的组件比 Nginx 多 。 现在 Nginx 才是 Web 服务器的首选 。链接","categories":[],"tags":[]},{"title":"md短代码怎么写","slug":"md短代码怎么写","date":"2019-12-19T09:15:15.000Z","updated":"2019-12-19T09:39:58.097Z","comments":true,"path":"post/2ffe5c2d.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/2ffe5c2d.html","excerpt":"QHQ-【问题描述】刚写了一篇博客，然后发现一个小bug，写的&lt;input&gt;&lt;/input&gt;字段发表出来是个文本输入框，然后看了看 Markdown 基本语句发现。。。。","text":"QHQ-【问题描述】刚写了一篇博客，然后发现一个小bug，写的&lt;input&gt;&lt;/input&gt;字段发表出来是个文本输入框，然后看了看 Markdown 基本语句发现。。。。如果正常直接在文章中写&lt;input&gt;&lt;/input&gt;，你得到的将会是这样：所以你需要看一下语法了，发现 &lt; 不是直接输入的，而是需要输入 &amp;lt；，来代替 &lt; ，&gt; 则是 *&amp;gt； *。所以你可以写&amp;lt；input&gt;&lt;/input*&amp;gt； *,这样就是&lt;input&gt;&lt;/input&gt; 。","categories":[],"tags":[]},{"title":"Java web 的form表单问题","slug":"JAVA Web的form表单问题","date":"2019-12-19T08:29:36.000Z","updated":"2019-12-19T09:04:18.866Z","comments":true,"path":"post/undefined.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/undefined.html","excerpt":"QHQ-【问题描述】今天做Java web项目的时候，里面一个功能让我form表单里面套表单了，但是里面的form 提交action中参数无效。直接action外层form，所以就记录下form表单的一些问题。","text":"QHQ-【问题描述】今天做Java web项目的时候，里面一个功能让我form表单里面套表单了，但是里面的form 提交action中参数无效。直接action外层form，所以就记录下form表单的一些问题。Form表单提交数据（Java web）java web 两个表单form怎么设置两个提交？也可以是一表单form，多提交。Acton只能有一个submit提交，在设置一个submit还是action外层form。所以怎么来用两个submit来指向不同的响应呢？一、使用formmethod和formaction属性在使用里面使用type=”submit” formmethod=”get” formaction=””即可。具体如下：123456789101112131415161718192021&lt;form action=\"query.do\" method=\"post\" align=\"center\"&gt; &lt;table border=\"1\" align=\"center\" text-align:center\"&gt; &lt;tr&gt; &lt;td&gt;&lt;%=book.getBookName()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getPrice()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getAuthor()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBr()%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getCounts()%&gt;&lt;/td&gt; &lt;td&gt; &lt;form action=\"edit.do?Id=&lt;%=book.getId()%&gt;\" method=\"get\"&gt; &lt;input type=\"text\" id=\"counts\" name=\"counts\"width:50px\" &gt; &lt;input type=\"hidden\" id=\"Id\" name=\"Id\" value=\"&lt;%=book.getId()%&gt;\" style=\"width: 0px\"&gt; &lt;input type=\"submit\" formmethod=\"get\" formaction=\"edit.do?Id=&lt;%=book.getId()%&gt;\" value=\"修改\"&gt;//调用edit方法，方式为get，（也可以修改为post，看自己需要） &lt;/form&gt; &lt;tr&gt; &lt;td colspan=\"7\"&gt;&lt;input type=\"submit\" value=\"查询\" /&gt;&lt;/td&gt;//调用qurry方法，方式为GET &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;二、设置不同函数，使用onclick属性1、表单中设置两个提交按钮：加密、解密；点击后分别调用不同的方法1234&lt;s:form id=\"Form\" action=\"\" namespace=\"/\"&gt; &lt;button onclick=\"encrypt()\"&gt;加密&lt;button&gt; &lt;button onclick=\"decrypt()\"&gt;解密&lt;/button&gt;&lt;s:form&gt;2、在不同的函数中设置要提交的地址123456789101112131415&lt;script&gt;//点击加密按钮调用此方法function encrypt()&#123; //跳转到encrypt.aciton document.getElementById(\"Form\") .action=\"$&#123;pageContext.request.contextPath&#125;/enAndDeAction_encrypt.action?\"; document.getElementById(\"Form\").submit; &#125; //点击加密按钮调用此方法function decrypt()&#123;document.getElementById(\"Form\").action=\"$&#123;pageContext.request.contextPath&#125;/enAndDeAction_decrypt.action?\";document.getElementById(\"Form\").submit; &#125;&lt;/script&gt;三、Form的Action路径问题页面通过表单（form）想服务器提交数据的时候有两种形式，一个是POST,另一个是GET。两种的一个区别是GET会直接把数据附加在url的后面，而POST发送的数据放置在http包中。form的action属性就是提交数据的url地址，method属性可以指定是GET或POST。需要注意的是如果采用GET方式，那么action url中参数都会被丢弃，提交时候只会把form中的数据拼接在url向服务器提交；但是POST的方式则不会这样，它会按照action指定的url进行提交数据，包含url后面跟着的参数和参数值我遇到的是Form表单提交到servelet处理时遇到的问题：123（1）&lt;form action=\"①？\" method=\"②？\"&gt; //表单的内容 &lt;/form&gt;（2）对应的处理用户请求的servlet类为Servlet.java，其中查询方法如下：123456789101112private void query(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO 自动生成的方法存根 req.setCharacterEncoding(\"UTF-8\");// 解决POST方法的中文乱码问题 t = req.getParameter(\"counts\"); // 1.调用CustomerDAO的getAll()方法 List&lt;User&gt; books = bd.findAll(); System.out.println(books); // 2.将Customer的集合放入request中 req.setAttribute(\"books\", books); // 3.转发页面到index.jsp(不能使用重定向) req.getRequestDispatcher(\"/book.jsp\").forward(req, resp); &#125;（3）配置web.xml文件：123456789&lt;servlet&gt; &lt;display-name&gt;③Servlet&lt;/display-name&gt; &lt;servlet-name&gt;Servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qhq.servlet.Servlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;③Servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;①*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;然后在query.jsp中应该是：1&lt;form action=\"①query.do\" method=\"②Post\"&gt;这样的话query.jsp的url是http://localhost:8080/jsp/query.do而Servlet.java的url是http://localhost:8080/jsp/Servlet注:web.xml中③对应的两个servlet-name要一致；①中的url-pattern要与form表单中的action属性值一致。参考连接如下：参考1参考2","categories":[],"tags":[]},{"title":"Win10无限刷新","slug":"Win10无限刷新","date":"2019-12-16T11:58:15.000Z","updated":"2019-12-19T09:39:58.096Z","comments":true,"path":"post/685c7446.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/685c7446.html","excerpt":"QHQ-【问题描述】​ 怎么样修复Win10系统 ，win10在选择默认应用就是更改不了，重置也没有反应，打开一个包含html文件的文件夹，桌面就无限刷新","text":"QHQ-【问题描述】​ 怎么样修复Win10系统 ，win10在选择默认应用就是更改不了，重置也没有反应，打开一个包含html文件的文件夹，桌面就无限刷新win10无限刷新我在使用电脑的时候，忽然发现我打开一个文件夹，桌面在无限刷新，于是就检查一下，发现是包含.html的文件夹都会造成这个无限刷新的bug。于是寻找解决办法。有以下两种：方法一：利用文件检查工具修复右击开始图标（电脑左下角的小图标），出现下面界面，点击管理员的Windows powerShell：然后输入sfc /scannow ，回车运行。方法二：即设置注册页来设置回到原始设置。先Win+R 打开运行界面，输入regedit，确定运行。接着按着箭头所指一步步走。都是左击，然后确定。选择完全控制，然后点击确定。之后就是确定，确定。。。（可能会反应一下，看自己电脑反应速度，我的是反应了两秒就好了），然后重启，即可。补充：如果第二点还没有反应，可以从控制面板→程序→默认程序→设置默认程序，自己再调整一下默认应用，也可以根据文件后缀名调整默认打开程序。","categories":[],"tags":[{"name":"Win10","slug":"Win10","permalink":"https://blog.qihaoqiang.cn/tags/Win10/"},{"name":"默认应用","slug":"默认应用","permalink":"https://blog.qihaoqiang.cn/tags/%E9%BB%98%E8%AE%A4%E5%BA%94%E7%94%A8/"},{"name":"html","slug":"html","permalink":"https://blog.qihaoqiang.cn/tags/html/"},{"name":"注册表","slug":"注册表","permalink":"https://blog.qihaoqiang.cn/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"},{"name":"无限刷新","slug":"无限刷新","permalink":"https://blog.qihaoqiang.cn/tags/%E6%97%A0%E9%99%90%E5%88%B7%E6%96%B0/"}]},{"title":"在人间凑数的日子(三）","slug":"在人间凑数的日子(三）","date":"2019-12-06T06:53:21.000Z","updated":"2019-12-06T13:01:17.061Z","comments":true,"path":"post/7562c651。.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/7562c651%E3%80%82.html","excerpt":"","text":"在人间凑数的日子（三）终于长到能与父亲碰杯的年纪，却没能成为他的骄傲。后来才发现，那并不是属于我的花，我只是途经她的绽放。曾以为贫穷是指饥饿，衣不附体，现在才懂得，它是孤独与无人问津。散伙是人间常态，我们又不是什么例外。一直想做一个特别的人，现在我做到了，我特别的无助，特别的难过。有时候也挺佩服自己，能咽下一肚子的话和心酸。条条大路通罗马，可有的人就出生在罗马。曾经有一个女孩儿追我，被我拒绝了，我没车没房，她不懂事，可我不能。所谓眉间的故事，不是喜欢就是辜负。后来我发现这世界真的很大，没有刻意见面，这辈子就再也见不到了。成熟，就是看以前的自己像个笨蛋。自你走后，好像不开心了好多年，原来不开心也可以成为习惯。回了趟故乡，故乡的气候一直没变，只是我却像个旅人。请不要用你那微不足道的成绩，来对我指指点点，因为我不配。","categories":[{"name":"在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/categories/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}],"tags":[{"name":"-在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/tags/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}]},{"title":"在人间凑数的日子（二）","slug":"在人间凑数的日子（二）","date":"2019-12-06T06:23:21.000Z","updated":"2019-12-06T08:00:46.044Z","comments":true,"path":"post/46848691.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/46848691.html","excerpt":"","text":"在人间凑数的日子（二）​ 年轻不懂爱情与友情，​ 长大后才懂得爱情是那么不容易，​ 友情是那么的脆弱。生活从来都是这样，不把我放在眼里。​ 你羡慕的生活背后，​ 都是你熬不起的苦。​ 自己都是满身灰暗，​ 还总想给别人一些光。​ 不要假装努力，​ 因为结果不会陪你演戏，​ 行为在于自己，未来依旧可期。​ 微笑并不代表快乐，​ 那只是一种表情。​ 你试图以离开引起别人的注意，​ 却不知道你是真的离开了，​ 并没有任何人记住你。​ 小时候总觉得要做什么样的人，​ 绝不能像某些人一样，​ 长大后，却成了当初最讨厌的人。​ 大事办不了，​ 小事不爱办。​ 很多道理我都懂，​ 结果无能想到也只能接受，​ 但是，我就是难受。​ 好看的皮囊你玩不起，​ 有趣的灵魂看不上你。​ 遗憾的是，​ 到最后我们连一张合照都没有。​ 我讨厌无边的猜忌和怀疑，​ 觉得人和人之间要多一点信任，​ 直到有一天，我把它们当成了兴趣。​ 她向你倾诉着寂寞，​ 你确认为那是爱情。​ 原来，所有失去的，会以另一种方式归来。​ 原来，虞美人终将盛开在这满山坡上。​ 原来，也终会有人陪我爱天爱地的四处风流。","categories":[{"name":"在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/categories/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}],"tags":[{"name":"-在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/tags/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}]},{"title":"在人间凑数的日子（一）","slug":"在人间凑数的日子（一）","date":"2019-12-06T05:53:21.000Z","updated":"2019-12-06T12:56:33.931Z","comments":true,"path":"post/76926a49.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/76926a49.html","excerpt":"","text":"在人间凑数的日子（一）鱼和熊掌不可兼得，唯独穷和单身可以。爷爷没有输给战火，父亲没有输给贫穷，我却输给了和平年代的生活和爱情，以及太过自由。我不记得小时候的梦想了，但绝对不是买一套房子。感觉什么都不缺，却又好像什么都没有。以为为是的深情，一厢情愿的热情。老说找不到理想中的另一半，问问自己，成为理想中的自己了吗？世界很美好，能让两个毫无关系的人走到一起，世界也很残酷，硬生生让两个相爱的人再没有未来。活着，就是一个接着一个的妥协。嫉妒使我面目全非，暗恋让我卑微入骨。自幼以为会有一番作为，衣锦还乡，现在想想，只希望父母在家过的好。有些事只适合烂在心里，无声无息的忘记。我到底经历了什么？才能收起暴躁的脾气和骄傲。","categories":[{"name":"在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/categories/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}],"tags":[{"name":"在人间凑数的日子","slug":"在人间凑数的日子","permalink":"https://blog.qihaoqiang.cn/tags/%E5%9C%A8%E4%BA%BA%E9%97%B4%E5%87%91%E6%95%B0%E7%9A%84%E6%97%A5%E5%AD%90/"}]},{"title":"关于Hexo主题的一些踩过的坑","slug":"关于Hexo主题的一些踩过的坑","date":"2019-11-24T05:48:07.341Z","updated":"2019-12-08T08:05:54.855Z","comments":true,"path":"post/7cf57d5c.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/7cf57d5c.html","excerpt":"","text":"Hexo主题的一些踩过的坑一、主题选择问题首先你需要在官网hexo选择你喜欢的主题。主要下载步骤有：Hxeo+Github pages。二、绑定域名问题每一次推送都会把你在setting设置的域名给覆盖，让你每一次都需要重新绑定一些域名，很麻烦。所以我就上网搜索与尝试，找到解决方法，首先在你hexo根目录找到source*目录，先新建.txt文件，在里面写入你要绑定的域名。再重命名为CNAME*，删除后缀名。使其没有后缀名，类型为文件。然后在github的setting里设置一次（保险设置一次，不设置也行）。三、主题内容更改在这只说一些我自己碰到的，基本上一般的坑网上都有详细教程。3.1、标题，作者和文字的更换​ 基本上在hexo*的根目录下的_config.yml*文件就可以更改了。注意：冒号后面需要空一格，不然会报错。默认语言为en，中文为zh—CN（有需要可以更改，一般不变）。3.2、js特效的更换添加​ 比如我的添加点击显示文字的特效：​ 以我选择miho主题为例，先添加点击显示文字的js（目录为..\\themes\\miho\\source\\js\\click_show_text.js）click_show_text.js：12345678910111213141516171819202122232425262728293031323334var a_idx = 0;jQuery(document).ready(function($) &#123; $(&quot;body&quot;).click(function(e) &#123; var a = new Array (&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;);//文字自己填写所想要的 var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; &quot;z-index&quot;: 5, &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;#FF0000&quot; &#125;); $(&quot;body&quot;).append($i); $i.animate(&#123; &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 &#125;, 3000, function() &#123; $i.remove(); &#125;); &#125;); setTimeout(&apos;delay()&apos;, 2000);&#125;);function delay() &#123; $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;);&#125;​ 然后需要在..\\themes\\miho\\layout\\layout.ejs添加语句： ` &lt;!--单击显示文字--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/click_show_text.js&quot;&gt;&lt;/script&gt; `​ 网上可以搜索自己喜欢的类型，步骤一样。未完待续","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.qihaoqiang.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.qihaoqiang.cn/tags/hexo/"}]},{"title":"bat批修改文件后缀名","slug":"bat简单批文件操作","date":"2019-11-10T16:00:00.000Z","updated":"2019-12-06T07:53:42.832Z","comments":true,"path":"post/642b6e07.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/642b6e07.html","excerpt":"","text":"今天先说说bat最简单的操作1ren *.jpg *.txt此语句可以把当前文件夹的所有jpg照片转换为txt格式，（有利于隐藏照片哦）。接下来就简单来说一下怎么具体操作吧新建txt文本在里面填写上面语句修改txt后缀名为bat提示：.jpg 意思是任意文件名的jpg格式，当然也可以.* ，表示任意文件文件格式，第二个*.txt意思是任意任意文件名的最终格式。就是原文件名不变，只修改后缀名。（后缀名可以根据自己的要求自己更改）。未完待续。。。","categories":[{"name":"bat","slug":"bat","permalink":"https://blog.qihaoqiang.cn/categories/bat/"}],"tags":[{"name":"bat","slug":"bat","permalink":"https://blog.qihaoqiang.cn/tags/bat/"},{"name":"文件后缀名修改","slug":"文件后缀名修改","permalink":"https://blog.qihaoqiang.cn/tags/%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%E4%BF%AE%E6%94%B9/"},{"name":"显示文件后缀名","slug":"显示文件后缀名","permalink":"https://blog.qihaoqiang.cn/tags/%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/"}]},{"title":"C++半数集问题","slug":"半数集","date":"2019-10-25T04:38:19.040Z","updated":"2019-12-06T07:50:48.214Z","comments":true,"path":"post/c5f70282.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/c5f70282.html","excerpt":"QHQ-【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：（1）n∈set(n);（2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；（3）按此规则进行处理，直到不能再添加自然数为止。","text":"QHQ-【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：（1）n∈set(n);（2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；（3）按此规则进行处理，直到不能再添加自然数为止。12345678910111213141516171819【问题描述】给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：（1）n∈set(n);（2）在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；（3）按此规则进行处理，直到不能再添加自然数为止。例如，set(6)=&#123;6,16,26,126,36,136&#125;。半数集set（6）中有6个元素。注意，该半数集是多重集。【算法设计】对于给定的自然数n，计算半数集set(n)中的元素个数。【输入形式】只有1行，给出整数n（0&lt;n&lt;1000）。【输出形式】只有1行，给出半数集set(n)中的元素个数。【样例输入】6【样例输出】61234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int my_set(int n)&#123; int set_count = 1; if (n == 1) return 1; else &#123; int i = 1; while (i &lt;= (n / 2)) &#123; set_count = set_count + my_set(i); i++; &#125; return set_count; &#125;&#125;int main()&#123; int n = 0; cin &gt;&gt; n; cout &lt;&lt; my_set(n);&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"半数集问题","slug":"半数集问题","permalink":"https://blog.qihaoqiang.cn/tags/%E5%8D%8A%E6%95%B0%E9%9B%86%E9%97%AE%E9%A2%98/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://blog.qihaoqiang.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++众数问题","slug":"众数问题","date":"2019-10-21T14:17:31.943Z","updated":"2019-12-06T07:53:06.645Z","comments":true,"path":"post/d2fd1ed9.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/d2fd1ed9.html","excerpt":"QHQ-【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。","text":"QHQ-【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。12345678910111213141516171819202122232425262728【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S=&#123;1,2,2,2,3,5&#125;。多重数S的众数是2，其重数为3 。【算法设计】对于给定的由n个自然数组成的多重集S，计算S的众数及其重数。【输入形式】第1行为多重数集S中元素个数n；接下来的n行中，每行有一个自然数。【输出形式】输出文件有2行，第1行是众数，第2行是重数。【样例输入】6122235【样例输出】231234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAXINT 10000int main()&#123; int n = 0; cin &gt;&gt; n; int a[MAXINT] = &#123; 0 &#125;; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + n); int maxcount = 0; int maxcount_index = 0; int temp = 1; int b[MAXINT] = &#123; 0 &#125;; b[0] = a[0]; int b_index = 1; bool flag = false; for (int i = 0; i &lt; (n - 1); i++) &#123; if (a[i] != a[i + 1]) &#123; b[b_index++] = a[i + 1]; flag = true; &#125; else temp++; if (maxcount &lt; temp) &#123; maxcount = temp; maxcount_index = (b_index - 1); &#125; if (flag) &#123; temp = 1; flag = false; &#125; &#125; cout &lt;&lt; b[maxcount_index] &lt;&lt; endl; cout &lt;&lt; maxcount;&#125;Sort() 数组排列函数。用法1、sort函数可以三个参数也可以两个参数，必须的头文件#include &lt; algorithm&gt;和using namespace std;2、它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)3、Sort函数有三个参数：（第三个参数可不写）（1）第一个是要排序的数组的起始地址。（2）第二个是结束的地址（最后一位要排序的地址）（3）第三个参数是排序的方法，可以是从大到小也可是从小到&gt;大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。两个参数用法1234567891011121314 #include &lt;iostream&gt; #include &lt;algorithm&gt; int main() &#123; int a[20]=&#123;2,4,1,23,5,76,0,43,24,65&#125;,i; for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; sort(a,a+20); for(i=0;i&lt;20;i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0; &#125; ``` &gt;输出结果是升序排列。（两个参数的sort默认升序排序）12---##三个参数 // sort algorithm example#include#include#includeusing namespace std;bool myfunction (int i,int j) { return (i&lt;j); }//升序排列bool myfunction2 (int i,int j) { return (i&gt;j); }//降序排列struct myclass {bool operator() (int i,int j) { return (i&lt;j);}} myobject;int main () {int myints[8] = {32,71,12,45,26,80,53,33};vectormyvector (myints, myints+8); // 32 71 12 45 26 80 53 33// using default comparison (operator &lt;):sort (myvector.begin(), myvector.begin()+4); //(12 32 45 71)26 80 53 33// using function as compsort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)//std::sort (myints,myints+8,myfunction);不用vector的用法// using object as compsort (myvector.begin(), myvector.end(), myobject); //(12 26 32 33 45 53 71 80)// print out content:cout &lt;&lt; “myvector contains:”;for (std::vector::iterator it=myvector.begin(); it!=myvector.end(); ++it)//输出cout &lt;&lt; ‘ ‘ &lt;&lt; *it;cout &lt;&lt; ‘\\n’;return 0;}12---## string 使用反向迭代器来完成逆序排列#includeusing namespace std;int main(){string str(“cvicses”);string s(str.rbegin(),str.rend());cout &lt;&lt; s &lt;&lt;endl;return 0;}//输出：sescivc```","categories":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://blog.qihaoqiang.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"众数问题","slug":"众数问题","permalink":"https://blog.qihaoqiang.cn/tags/%E4%BC%97%E6%95%B0%E9%97%AE%E9%A2%98/"}]},{"title":"C++金币阵列","slug":"金币阵列","date":"2019-10-21T12:26:55.162Z","updated":"2019-12-06T07:51:12.912Z","comments":true,"path":"post/ec6b291e.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/ec6b291e.html","excerpt":"QHQ-【问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上，1表示金币背面朝上。金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。","text":"QHQ-【问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上，1表示金币背面朝上。金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。1234567891011121314151617181920212223242526问题描述】有m*n(m&lt;=100, n&lt;=100)枚金币在桌面上排成一个m行n列的金币矩阵。每枚金币或正面朝上或背面朝上。用数字表示金币状态，0表示金币正面朝上， 1表示金币背面朝上。金币矩阵游戏的规则是：1.每次可将任一行金币翻转过来放在原来的位置上；2.每次可任选2列，交换着2列金币位置。算法设计：给定金币阵列的初始状态和目标状态，计算按金币游戏规则，将金币阵列从初始状态转换到目标状态所需要的最小变换次数。【输入形式】第1行有2个正整数m和n，用#隔开。以下m行是金币阵列的初始状态，每行有n个数字表示该行金币的状态，0表示正面朝上，1表示背面朝上。接着的m行是金币阵列的目标状态，不用#隔开 。【输出形式】输出计算出的最小变化次数。相应数据无解是，输出-1 。【样例输入】4#3101000110101101111011101【样例输出】2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;const int size1 = 100;int k, n, m, ccount, best;int b0[size1 + 1][size1 + 1], b1[size1 + 1][size1 + 1], b[size1 + 1][size1 + 1];bool found;void stringToInt(string str,int&amp; n,int&amp; m)&#123; int len = str.length(); int temp = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] != &apos;#&apos;) &#123; temp = temp * 10 + (int)str[i] - 48; &#125; else &#123; n = temp; temp = 0; &#125; &#125; m = temp;&#125;void trans1(int x) // 行翻转&#123; for (int i = 1; i &lt;= m; i++) b1[x][i] = b1[x][i] ^ 1; ccount++;&#125;void trans2(int x, int y) // 列交换&#123; for (int i = 1; i &lt;= n; i++) swap(b1[i][x], b1[i][y]); if (x != y) ccount++;&#125;bool same(int x, int y)&#123; for (int i = 1; i &lt;= n; i++) if (b0[i][x] != b1[i][y]) return false; return true;&#125;void acpy(int a[size1 + 1][size1 + 1], int b[size1 + 1][size1 + 1])&#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[i][j] = b[i][j];&#125;void answer()&#123; int x, y, j, p; //cin &gt;&gt; n &gt;&gt; m; string str; int temp = 0; cin &gt;&gt; str; stringToInt(str, n, m); // 原状态 b0 for (x = 1; x &lt;= n; x++) &#123; cin &gt;&gt; temp; for (y = 1; y &lt;= m; y++) &#123; b0[x][y] = temp % 10; temp /= 10; //cin &gt;&gt; b0[x][y]; &#125; &#125; // 目标状态 b1 for (x = 1; x &lt;= n; x++) &#123; cin &gt;&gt; temp; for (int y = 1; y &lt;= m; y++) &#123; b1[x][y] = temp % 10; temp /= 10; //cin &gt;&gt; b1[x][y]; &#125; &#125; acpy(b, b1); best = m + n + 1; for (j = 1; j &lt;= m; j++) &#123; acpy(b1, b); ccount = 0; trans2(1, j); // 列变换 int p; for (p = 1; p &lt;= n; p++) if (b0[p][1] != b1[p][1]) trans1(p); // 行变换 for (p = 1; p &lt;= m; p++) //找列相等的（ b1 的 q 列和 b0 的 p 列相等） &#123; found = false; for (int q = p; q &lt;= m; q++) if (same(p, q)) &#123; trans2(p, q); found = true; break; &#125; if (!found) break; &#125; if (found &amp;&amp; ccount &lt; best) best = ccount; &#125; if (best &lt; m + n + 1) &#123; cout &lt;&lt; best &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; //&#125;&#125;int main()&#123; answer(); return 0;&#125;StringToint() 函数获取输入的特殊格式，并分发数据给行n，列m。trans1() 和 trans2() 为行转换与列转换。","categories":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://blog.qihaoqiang.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"金币阵列","slug":"金币阵列","permalink":"https://blog.qihaoqiang.cn/tags/%E9%87%91%E5%B8%81%E9%98%B5%E5%88%97/"}]},{"title":"C++最大间隙","slug":"最大间隙","date":"2019-10-21T11:49:44.984Z","updated":"2019-12-06T07:53:18.716Z","comments":true,"path":"post/f08763f0.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/f08763f0.html","excerpt":"QHQ-【问题描述】给定n个实数x1,x2,…,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。","text":"QHQ-【问题描述】给定n个实数x1,x2,…,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。12345678910111213【问题描述】给定n个实数x1,x2,...,xn, 求着n个数在实轴上相邻两个数之间的最大差值。假设对任何实数的下取整函数好事O(1), 设计解最大间隙问题的线性时间算法。算法设计：对于给定的n个实数x1,x2,...,xn，计算它们的最大间隙。（只有一位小数）【输入形式】第一行有1个正整数n（n不超过10），接下来的1行有n个实数x1,x2,...,xn，中间用空格隔开。【输出形式】输出找到的最大间隙【样例输入】52.3 3.1 7.5 1.5 6.3【样例输出】3.2（保留一位小数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;const int MAX = 200001;double num[MAX];bool run()&#123; int n; if (scanf_s(&quot;%d&quot;, &amp;n) == EOF) return false; int i; double max = 0.0, min = INT_MAX; for (i = 0; i &lt; n; i++) &#123; scanf_s(&quot;%lf&quot;, &amp;num[i]); if (num[i] &gt; max) max = num[i]; if (num[i] &lt; min) min = num[i]; &#125; int* cnt = new int[n]; double* low = new double[n]; double* high = new double[n]; for (i = 0; i &lt; n; i++) &#123; cnt[i] = 0; low[i] = max; high[i] = min; &#125; double ave = (max - min) / (n - 1); for (i = 0; i &lt; n; i++) &#123; int tmp = (int)((num[i] - min) / ave); cnt[tmp]++; if (num[i] &gt; high[tmp]) high[tmp] = num[i]; if (num[i] &lt; low[tmp]) low[tmp] = num[i]; &#125; double t = high[0], res = 0.0; for (i = 1; i &lt; n; i++) &#123; if (cnt[i] &gt; 0) &#123; double tmp = low[i] - t; if (tmp &gt; res) res = tmp; t = high[i]; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; res &lt;&lt; endl; return true;&#125;int main()&#123; while (run()); return 0;&#125;因为我用的是vs2019，所以在scanf输出的时候会出现 C6031:返回值被忽略的问题：“scanf”，所以需要改写scanf为scanf_s。题目要求结果有一位小数，在C++中，是没有格式符的，所以想起用setprecision() 函数，但是使用这个函数，需要在头文件引入 #include，使用方式在此再简单回顾一下：1cout &lt;&lt; setprecision(2) &lt;&lt; res &lt;&lt;endl;这是保留小数点后两位（但是如果结果是整数则是整数，不自动 补零）1cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; res &lt;&lt; endl;在前面加上 fixed 就可以自动补零。3.再次附一个小吕哥的源码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define MAXINT 100000using namespace std;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; endl; double a[MAXINT] = &#123;0.0 &#125;; for(int i = 0;i &lt; n;i++)&#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n); double maxsub = 0.0; double temp = 0.0; for(int i = 0;i &lt; (n - 1);i++)&#123; temp = fabs(a[i] - a[i + 1]); if(maxsub &lt; temp)&#123; maxsub = temp; &#125; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; maxsub;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"计算机算法与设计","slug":"计算机算法与设计","permalink":"https://blog.qihaoqiang.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"最大间隙","slug":"最大间隙","permalink":"https://blog.qihaoqiang.cn/tags/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%99/"},{"name":"C++格式化输出","slug":"C-格式化输出","permalink":"https://blog.qihaoqiang.cn/tags/C-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"}]},{"title":"干掉bashhexocommand not found","slug":"干掉bashhexocommand not found","date":"2019-10-19T09:44:51.024Z","updated":"2020-03-27T10:26:39.247Z","comments":true,"path":"post/c1993ac1.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/c1993ac1.html","excerpt":"","text":"好久没动过 Hexo 博客了，都是在用halo博客,今天准备一起更新的时候输入 hexo new linving新建时，报错 bash: hexo: command not found，忽然不知道咋回事了,就想到前不断时间重置电脑了,可能一些配置都没有了,就检查一下,并完美解决了!若是git也没有的,请先下载git,可以选择这个链接下载git(Git-2.26.0-64-bit)和node(node-v12.16.1-x64).https://www.lanzous.com/b00zckh7c密码:7r7z一、检查node和npm是否正常.不正常就先下载,若正常直接跳转第四步.二、选择node下载.推荐https://nodejs.org/en/download/官网直接下载.也可以选择上面的打包下载(git和node).下载和傻瓜式安装就可,安装完成时环境配置也一起好了.我们可以看到环境变量中已经包含了E:\\node\\三、检查Node.js和npm版本​ 安装完node需重新打开git.下面是我重新打开后,想直接建立新文件,但是没有成功,但是node和npm都OK.发现虽然有了版本信息又证明 nodejs 和 npm 是没有问题的，但还是没有建立成功,那么就应该是环境变量的配置问题了.四、配置环境变量【CTRL】+【E】打开文件资源管理器,在左侧栏中选择【此电脑】右键【属性】，依次选择【高级系统设置】-【环境变量】，选择系统变量 Path，将 node_modules 下的 .bin 文件路径添加到 Path 里面.环境变量添加好了之后重新打开 git 即可运行 hexo 命令 即可！五、如以上都不行,请卸载hexo重新安装.运行命令 npm install hexo-cli -g 重新安装 hexo ！","categories":[],"tags":[]},{"title":"C++分割输入字符串","slug":"C++格式化输入","date":"2019-10-17T15:13:42.687Z","updated":"2019-12-06T07:53:52.972Z","comments":true,"path":"post/dab5e751.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/dab5e751.html","excerpt":"QHQ-It was day full of memories","text":"QHQ-It was day full of memoriesC++字符串分割C++没有split分割的函数！！！！C++没有c语言的那样方便的格式化输入，像c语言你如果想一次性输入1#2，而分别把1和2赋值给x和y，你可以这样：1scanf(&quot;%d#%d&quot;,&amp;x,&amp;y);当然你也可以自己定义一个方法来实现这个想法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstddef&gt;#include &lt;vector&gt;using namespace std;namespace strg&#123; //函数模板 template&lt;typename Container&gt; inline std::size_t strtok(std::string&amp; str, Container&amp; cont, const std::string defstr = &quot; &quot;) &#123; cont.clear(); std::size_t size = 0; std::size_t begpos = 0 ; std::size_t endpos = 0 ; begpos = str.find_first_not_of(defstr); while (begpos != std::string::npos) &#123; size++; endpos = str.find_first_of(defstr, begpos); if (endpos == std::string::npos) &#123; endpos = str.size(); &#125; string ssubstr = str.substr(begpos, endpos -begpos); cont.push_back(ssubstr); //将分割的字符串存入容器当中 begpos = str.find_first_not_of(defstr, endpos+1); &#125; return size; &#125; template&lt;typename Container&gt; inline size_t stringtok(std::string&amp; str, Container&amp; cont, const std::string defstr = &quot; &quot;) &#123; cont.clear(); std::size_t size = 0; std::size_t length = str.length(); std::size_t begpos = 0; std::size_t endpos = 0; while (begpos &lt; length) &#123; size++; begpos = str.find_first_not_of(defstr,begpos); if (begpos == std::string::npos) return -1; endpos = str.find_first_of(defstr, begpos); if (endpos == std::string::npos) &#123; endpos = length; &#125; string ssubstr = str.substr(begpos, endpos - begpos); cont.push_back(ssubstr); begpos = endpos + 1; &#125; return size; &#125;&#125;int main()&#123; string str = &quot;- This, a sample string.&quot;; vector&lt;string&gt; vec; int size = strg::strtok(str,vec,&quot;-,. &quot;); for (auto&amp; it : vec) cout &lt;&lt; it &lt;&lt; &quot; &quot;; cout&lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;而我今天主要想说的是另一个巧妙的方法：用一个小变量temp来中转:123456789101112131415161718192021int main()&#123; string str; int x = 0; int y = 0; cin&gt;&gt;str; int s = str.length(); int temp = 0; for(int i = 0; i&lt;s; i++) &#123; if(str[i] != &apos;#&apos;) &#123; temp = temp * 10 + (int)str[i] -48; &#125; else &#123; x = temp; temp = 0; &#125; &#125;y = temp;这样如果你想输入1#2，它就会通过temp中转后分别赋值给x=1和y=2，这个例子仅是转换为想要的数值int型。","categories":[{"name":"First","slug":"First","permalink":"https://blog.qihaoqiang.cn/categories/First/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.qihaoqiang.cn/tags/C/"},{"name":"格式化输入","slug":"格式化输入","permalink":"https://blog.qihaoqiang.cn/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5/"},{"name":"分割字符串","slug":"分割字符串","permalink":"https://blog.qihaoqiang.cn/tags/%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"第一次测试尝试！","slug":"First","date":"2019-10-16T13:34:46.488Z","updated":"2019-12-06T07:54:03.409Z","comments":true,"path":"post/4ef2f023.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/4ef2f023.html","excerpt":"QHQ-This is a nice day","text":"QHQ-This is a nice dayWhy Blog对博客的理解喜欢写Blog的人，会经历三个阶段。第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。我们每个人的在网络上产生的数据越来越多，这些信息是我们在互联网上存在过的痕迹，值得我们认真对待。但是它们被分散分布在各个网站上。很多时候我们很难将它们聚合在一起，而且各个网站的信息排布方式也没有办法自由控制，所以我们需要一个可以由自己主宰的空间——博客。通过博客，我们可以记录自己的生活和成长的轨迹。它不像 Twitter 那样碎片化，也不像 Facebook 那样关系化，它是私人的空间。关于巴尔巴尔郝图 是小柒（戚浩强）的个人站。一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。TablesAreCoolcol 3 isright-aligned$1600col 2 iscentered$12zebra stripesare neat$1","categories":[{"name":"First","slug":"First","permalink":"https://blog.qihaoqiang.cn/categories/First/"}],"tags":[{"name":"First","slug":"First","permalink":"https://blog.qihaoqiang.cn/tags/First/"},{"name":"Second","slug":"Second","permalink":"https://blog.qihaoqiang.cn/tags/Second/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-16T09:56:10.900Z","updated":"2019-12-06T07:54:12.759Z","comments":true,"path":"post/4a17b156.html","link":"","permalink":"https://blog.qihaoqiang.cn/post/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]}]}